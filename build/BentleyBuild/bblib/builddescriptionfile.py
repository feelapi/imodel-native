#---------------------------------------------------------------------------------------------
#  Copyright (c) Bentley Systems, Incorporated. All rights reserved.
#  See LICENSE.md in the repository root for full copyright notice.
#---------------------------------------------------------------------------------------------

#
#  I have intentionally kept this file clean from the rest of BentleyBuild so that we can
#  use it as part of BentleyBootstrap as well, since both need to be able to handle these files.
#

import codecs, os, datetime, fnmatch, json, re, sys, time

from xml.dom import minidom
import xml

py3 = (int(sys.version[0]) > 2)

# Python 2/3 compatability
if py3:
    from urllib.request import urlopen, Request
    from urllib.error import HTTPError, URLError
else:
    from future.moves.urllib.request import urlopen, Request
    from future.moves.urllib.error import HTTPError, URLError

# Leave these when removing Private.
BDF_SERVER_NAME = ''
BDF_API_SERVER_NAME = ''

BUILDS_UNQUALIFIED = ''
BUILDS_QUALIFIED = ''
BUILDS_RSYNC = ''

DEFAULT_BUILD_TYPE = 'BentleyBuild'

BUILDTIME_FORMAT = "%a %b %d %Y %H:%M:%S"
GIT_BRANCH_TAG_IDENTIFIER = 'Branch::'

# These are the parts of the BDF we want in the config file
CONFIG_FIELDS = ['HgRepositories','CvsRepositories','RsyncRepositories','GitRepositories',
                    'SdkSources','NugetPackages','UniversalPackages', 'LkgSubParts', 'Bootstrap']

#-------------------------------------------------------------------------------------------
# bsimethod
#-------------------------------------------------------------------------------------------
def _getUrl (url, headers):
    # Duplicated here because I don't want to add a dependency on compat.py.
    httpCode = 200 # assume success
    httpContent = None
    try:
        httpRequest = Request(url, headers=headers)
        httpResponse = urlopen(httpRequest)
        httpCode = httpResponse.getcode()
    except HTTPError as e:
        httpCode = e.code
    if 200 == httpCode:
        httpContent = httpResponse.read()
    return httpCode, httpContent

# Change the LKGType and Url depending on the environment since we want the PRG to use fileshare 
# and everyone else to use rsync for better pull performance when using builds server
# We have to change type at runtime since the BDFs generated by PRG will always have fileshare and Azure DevOps builds will have rsync
#-------------------------------------------------------------------------------------------
# bsimethod
#-------------------------------------------------------------------------------------------
def ProcessLKGTypeAndUrlForEnvironment (lkgType, url):
    if not 'BSI' in os.environ:
        return

    if "SUBNET_PRG" not in os.environ or 'TF_BUILD' in os.environ:
        if lkgType == 'fileshare':
            if url.startswith(BUILDS_UNQUALIFIED):
                return 'rsync', url.replace(BUILDS_UNQUALIFIED, BUILDS_RSYNC)
            elif url.startswith(BUILDS_QUALIFIED):
                return 'rsync', url.replace(BUILDS_QUALIFIED, BUILDS_RSYNC)
    elif lkgType == 'rsync' and url.startswith(BUILDS_RSYNC):
        return 'fileshare', url.replace(BUILDS_RSYNC, BUILDS_QUALIFIED)
    return lkgType, url

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class BuildDescriptionError (Exception):
    pass

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class ComparableForJson (object):  # Only for writing JSON sorted so we can compare
    def uniqueName(self):
        raise BuildDescriptionError ('must implement uniqueName')
    def __lt__(self, other): return self._Compare (other) < 0
    def __eq__(self, other): return self._Compare (other) == 0
    def __ne__(self, other): return self._Compare (other) != 0
    def __gt__(self, other): return self._Compare (other) > 0
    def __le__(self, other): return self._Compare (other) <= 0
    def __ge__(self, other): return self._Compare (other) >= 0
    def _Compare (self, other):
        if self.uniqueName().lower() < other.uniqueName().lower():
            return -1
        if self.uniqueName().lower() > other.uniqueName().lower():
            return 1
        return 0

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class RepoTagDictEntry (object):
    """Class to contain information about a single CVS repository"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, repo, tag, url, path):
        self.Name = repo
        self.Tag  = tag
        self.Url  = url
        self.Path = path

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class ADOBuildProperties (object):
    """Class to contain information about ADO Build Properties"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, agentName, buildNumber, buildUri, buildDefinitionName, buildDefinitionId, buildQueuedBy,
                  buildReason, buildRequestedFor, buildSourceBranchName, adoBuildId, projectId, projectName, name, organizationId):
        self.AgentName = agentName
        self.BuildNumber  = buildNumber
        self.BuildUri  = buildUri
        self.BuildDefinitionName = buildDefinitionName
        self.BuildDefinitionId = buildDefinitionId
        self.BuildQueuedBy = buildQueuedBy
        self.BuildReason = buildReason
        self.BuildRequestedFor = buildRequestedFor
        self.BuildSourceBranchName = buildSourceBranchName
        self.ADOBuildId = adoBuildId
        self.ProjectId = projectId
        self.ProjectName = projectName
        self.OrganizationName = name
        self.OrganizationId = organizationId

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class RsyncRepoDictEntry (object):
    """Class to contain information about a single Rsync repository"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, repo, tag, url, path):
        self.Name = repo
        self.Tag  = tag
        self.Url  = url
        self.Path = path

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class SdkSourceDictEntry (object):
    """Class to contain information about a single Sdk Source"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, repoName, version, prgName, sdkName):
        self.Name           = repoName
        self.Version        = version
        self.PrgOutputDir   = prgName
        self.SdkName        = sdkName

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class NugetPackageDictEntry (ComparableForJson):
    """Class to contain information about a single Nuget package"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, packageName, alias, packageUrl, version):
        self.Name       = packageName
        self.Alias      = alias
        self.Version    = version
        self.Url        = packageUrl
    def uniqueName(self):
        return '{0}:{1}:{2}'.format(self.Name, self.Alias, self.Version)
    def __hash__(self):
        return hash(self.uniqueName())

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class NpmPackageDictEntry (object):
    """Class to contain information about a single Npm package"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, packageName, packageUrl, version, dev):
        self.Name       = packageName
        self.Version    = version
        self.Url        = packageUrl
        self.Dev        = dev
    @staticmethod
    def MakeKey (packageName, version):
        return packageName+'@'+version

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class UpackDictEntry (ComparableForJson):
    """Class to contain information about a single universal package"""
    def uniqueName(self):
        return '{0}:{1}:{2}'.format(self.Name, self.Alias, self.Version)
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, name, alias, version, url, feed):
        self.Name       = name
        self.Alias      = alias
        self.Version    = version
        self.Url        = url
        self.Feed       = feed
    def __hash__(self):
        return hash(self.uniqueName())

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class ADOBuildArtifactDictEntry (ComparableForJson):
    """Class to contain information about a single azure devops build artifact"""
    def uniqueName(self):
        return '{0}:{1}:{2}:{3}:{4}:{5}'.format(self.Alias, self.Name, self.ADOBuildId, self.DefinitionId, self.Project, self.Organization)
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, alias, name, adobuildId, definitionid, project, organization):
        self.Alias        = alias
        self.Name         = name
        self.ADOBuildId   = adobuildId
        self.DefinitionId = definitionid
        self.Project      = project
        self.Organization = organization
    def __hash__(self):
        return hash(self.uniqueName())

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class PackageLicenseEntry (ComparableForJson):
    """Class to contain license information about a NuGet or NPM package"""
    def uniqueName(self):
        return "{0}:{1}:{2}:{3}:{4}".format(self.PackageName, self.Version, self.Type, self.SubpackageName, self.SubpackageVersion)
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, packageName, version, homepage, spdx, licenseUrl, pkgCopyright, pkgType, subpackageName = None, subpackageVersion = None):
        # Using real names because the object is passed as JSON
        self.PackageName        = packageName
        self.Version            = version
        self.PackageHomePage    = homepage
        self.LicenseName        = spdx
        self.LicenseLink        = licenseUrl
        self.Copyright          = pkgCopyright
        self.Type               = pkgType
        self.SubpackageName     = subpackageName
        self.SubpackageVersion  = subpackageVersion
    def __hash__(self):
        return hash(self.uniqueName())
    def __eq__(self, other):
        return self.uniqueName() == other.uniqueName()

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class LkgPartMapItem (ComparableForJson):  # Only for writing JSON sorted so we can compare
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, name, partName):
        self.Name = name
        self.PartName = partName
    def uniqueName(self):
        return "{0}:{1}".format(self.Name, self.PartName)

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class EnvironmentItem (ComparableForJson):  # Only for writing JSON sorted so we can compare
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, name, value):
        self.Name = name
        self.Value = value
    def uniqueName(self):
        return self.Name

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class RepoGuidDictEntry (object):
    """Class to contain information about a single Hg repository"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, repo, guid, url, fromLKG):
        self.Name = repo
        self.Guid = guid
        self.Url  = url
        self.FromLkgs = fromLKG

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class CreatedPackageEntry (object):
    """Class to contain information about a package (nuget, npm) created by this build"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, name, version, pkgtype, url):
        self.Name = name
        self.Version = version
        self.Type = pkgtype
        self.Url = url
    @staticmethod
    def MakeKey (packageName, version):
        # recycle the one for NPM packages and apply it to all
        return NpmPackageDictEntry.MakeKey (packageName, version)

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class GitRepoGuidDictEntry (object):
    """Class to contain information about a single Git repository"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, repo, guid, url, fromLKG):
        self.Name = repo
        self.Guid = guid
        self.Url  = url
        self.FromLkgs = fromLKG
        self.Branch = None  # Used for config file
        self.UseBranch = False

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class LKGSubPartDictEntry (ComparableForJson):
    """Class to contain information about a single LKG from SubParts"""
    # Member names reflect what is expected in the json; do not change.
    def __init__ (self, name, topLevelPartName, relV, majV, minV, buildNum, lkgType, url):
        self.Name               = name
        self.TopLevelPartName   = topLevelPartName
        self.ReleaseVersion     = int(relV)
        self.MajorVersion       = int(majV)
        self.MinorVersion       = int(minV)
        self.BuildNumber        = int(buildNum)
        self.LKGType            = lkgType
        self.Url                = url

    def uniqueName(self):
        return "{0}:{1}".format(self.Name, self.TopLevelPartName)

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class BundleEntry (object):
    def __init__(self, name, path, organizationName, project, artifactName, azureBuildId):
        self.Name = name
        self.Path = path
        self.OrganizationName = organizationName
        self.Project = project
        self.ArtifactName = artifactName
        self.AzureBuildId = azureBuildId

#-------------------------------------------------------------------------------------------
# bsiclass
#-------------------------------------------------------------------------------------------
class BootstrapInfo (ComparableForJson):
    def __init__ (self, repoName, repoType, isPrimary, localDir):
        self.RepoType = repoType
        self.Name = repoName
        self.IsPrimary = True if isPrimary else False
        self.LocalDir = localDir

    def uniqueName(self):
        return "{0}:{1}".format(self.Name, self.RepoType)

#-------------------------------------------------------------------------------------------
# Work with Build Description files
# bsiclass
#-------------------------------------------------------------------------------------------
class BuildDescription (object):
    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def __init__(self, fileName=None):
        self.m_repoGuidDict = {}
        self.m_gitRepoGuidDict = {}
        self.m_strategyName = None
        self.m_adoBuildProperties = None
        self.m_filePath = fileName
        self.m_PRGDirName = None
        self.m_buildType = DEFAULT_BUILD_TYPE
        self.m_lkgSubPartDict = {}
        self.m_prodName = "UnknownProductName"
        self.m_prgProductId = 0
        self.m_version = [0, 0, 0, 0]
        self.m_buildTimeIso = None
        self.m_repoTagDict = {}
        self.m_rsyncRepoDict = {}
        self.m_sdkSourceRepoDict = {}
        self.m_nugetPackages = set()
        self.m_npmPackageDict = {}
        self.m_streamName  = None
        self.m_lkgMapEntries = {}
        self.m_writeEnvironment  = False
        self.m_environment = {}
        self.m_usedContexts = set()
        self.m_createdPackages = {}
        self.m_nugetPackageLicenses = []
        self.m_npmPackageLicenses = []
        self.m_bundles = {}
        self.m_unsavedLkgs = {}
        self.m_upacks = set()
        self.m_adoBuildArtifacts = set()
        self.m_bootstrapInfo = {}

        if ("PrgProductId" in os.environ):
            self.m_prgProductId = int(os.environ['PrgProductId'])

        if fileName:
            self.m_sourceName = "file: " + fileName
        else:
            self.m_sourceName = None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    @staticmethod
    def GetServerAndHeaders(headers=None):
        token = os.environ.get('BSI_BDF_TOKEN', None)
        serverName = BDF_API_SERVER_NAME if token else BDF_SERVER_NAME 
        if headers == None:
            headers = {}
        if token:
            headers ['Token'] = token
        return serverName, headers

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    @staticmethod
    def PostBuildDescriptionToDatabase(buildDesc, retries=5, messages=None):
        headers = {}
        headers ['Content-Type'] = "text/json"
        headers ['From'] = os.environ.get("USERNAME")
        serverName, headers = BuildDescription.GetServerAndHeaders(headers)

        url = serverName + "api/products"
        jsonString = json.dumps(buildDesc.WriteToJSON())

        if None != messages:
            messages.append ('Posting BDF {0}'.format (url))

        sleepTime = 0.5
        attempt = 0
        while attempt < retries:
            attempt += 1

            try:
                request = Request(url, jsonString, headers)
                httpResponse = urlopen(request)
                httpCode, message = httpResponse.getcode(), httpResponse.msg
                if 200 == httpCode or 201 == httpCode:
                    break
                if None != messages:
                    messages.append ('Attempt {0} Failed to get BDF; http code = {1}'.format (attempt, httpCode))
                time.sleep (sleepTime)
                sleepTime = sleepTime + 1 if sleepTime < 7 else sleepTime # Try sleepging a little longer each time, but not too long.

            except HTTPError as e: # (424) Bad data or (401) authorization error or (409) duplicate; no point in retrying
                if 424 == e.code or 409 == e.code:
                    jsonTxt = e.read()
                    return e.code, json.loads(jsonTxt)
                if 401 == e.code:
                    return e.code, e.msg
                httpCode, message = e.code, e.msg # May retry.
            except URLError:
                return 1, "Connection to {0} refused".format(serverName)

        return httpCode, message

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    @staticmethod
    def QueryDatabaseForBuildDescription(name, versionList, retries=5, messages=None):
        if 4 != len(versionList):
            raise BuildDescriptionError ("\nERROR: no version given.\n")
        if None == name or '' == name:
            raise BuildDescriptionError ("\nERROR: no product name given\n")

        serverName, headers = BuildDescription.GetServerAndHeaders(None)

        requestUrl =  '{0}api/products?Product={1}&Release={2}&Major={3}&Minor={4}&Build={5}'.format (serverName, name, versionList[0], versionList[1], versionList[2], versionList[3])
        if None != messages:
            messages.append ('Querying for BDF {0}\n'.format (requestUrl))
        try:
            sleepTime = 0.5
            attempt = 0
            while attempt < retries:
                attempt += 1
                httpCode, jsonText = _getUrl (requestUrl, headers)
                if 200 == httpCode:
                    break
                if None != messages:
                    messages.append ('Attempt {0} Failed to get BDF; http code = {1}\n'.format (attempt, httpCode))
                time.sleep (sleepTime)
                sleepTime = sleepTime + 1 if sleepTime < 7 else sleepTime # Try sleepging a little longer each time, but not too long.
        except Exception as e:
            raise BuildDescriptionError ('\n{0}'.format(e))

        if 200 != httpCode:
            httpMessages = '\n'.join (messages) if messages else ''
            raise BuildDescriptionError ("\nERROR: Build Description {0}_{1}-{2}-{3}-{4} could not be read (http error {5})\n{6}".format(name, versionList[0], versionList[1], versionList[2], versionList[3], httpCode, httpMessages))

        if '{}' == jsonText:
            raise BuildDescriptionError ("\nERROR: Build Description {0}_{1}-{2}-{3}-{4} does not exist in database\n".format(name, versionList[0], versionList[1], versionList[2], versionList[3]))
        
        buildDesc = BuildDescription ()
        status = buildDesc.ReadFromJSON(jsonText)
        verTuple = buildDesc.GetProductVersion()
        buildDesc.m_sourceName = 'BDFServer: {0} {1}.{2}.{3}.{4}'.format (name, verTuple[0], verTuple[1], verTuple[2], verTuple[3])
        
        if 1 == status:
            raise BuildDescriptionError ("\nERROR: Build Description {0}_{1}-{2}-{3}-{4} from server could not be read by system\n".format(name, versionList[0], versionList[1], versionList[2], versionList[3]))

        return buildDesc, 0

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def Dump (self):
        def OutputMsg (msg):
            # To evade pylint's aversion to print, and so we know it's not temp debugging output.
            sys.stdout.write (msg+'\n')
    
        OutputMsg ("--------------------------------------------------------")
        OutputMsg ("Build Description Data")
        OutputMsg ("--------------------------------------------------------")
        keylist = list(self.m_repoGuidDict.keys())
        keylist.sort()
        for key in keylist:
            entry = self.m_repoGuidDict[key]
            OutputMsg ('{0}, {1}, {2}, {3}'.format (entry.Name, entry.Guid, entry.Url, entry.FromLkgs))

        OutputMsg ('------------------')
        for key in self.m_lkgSubPartDict:
            lkgSubPartEntry = self.m_lkgSubPartDict[key]
            OutputMsg ('{0}, {1}.{2}.{3}.{4}, {5}, {6}'.format (key, lkgSubPartEntry.ReleaseVersion, lkgSubPartEntry.MajorVersion, lkgSubPartEntry.MinorVersion, lkgSubPartEntry.BuildNumber, lkgSubPartEntry.LKGType, lkgSubPartEntry.Url))

        OutputMsg ('------------------')
        keylist = list(self.m_repoTagDict.keys())
        keylist.sort()
        for key in keylist:
            entry = self.m_repoTagDict[key]
            OutputMsg ('{0}, {1}'.format (key, entry.Tag))

        OutputMsg ('------------------')
        keylist = list(self.m_rsyncRepoDict.keys())
        keylist.sort()
        for key in keylist:
            entry = self.m_rsyncRepoDict[key]
            OutputMsg ('{0}, {1}, {2}'.format (key, entry.Path, entry.Tag))

        OutputMsg ('------------------')
        keylist = list(self.m_gitRepoGuidDict.keys())
        keylist.sort()
        for key in keylist:
            entry = self.m_gitRepoGuidDict[key]
            OutputMsg ('{0}, {1}, {2}, {3}'.format (entry.Name, entry.Guid, entry.Url, entry.FromLkgs))

    #-------------------------------------------------------------------------------------------
    #  Sometimes need to defer loading.  Store the path.
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def SetPath (self, filePath):
        self.m_filePath = filePath

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def SetStrategy (self, strategy):
        self.m_strategyName = strategy

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def SetStreamName (self, streamName):
        self.m_streamName = streamName 

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetStreamName (self):
        return self.m_streamName

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def SetPrgBuildName (self, buildName):
        self.m_PRGDirName = buildName

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def StoreEnvironmentVars(self):
        self.m_writeEnvironment  = True

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetPrgBuildName (self):
        return self.m_PRGDirName

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def SetVersion (self, prodName, relV, majV, minV, subminV):
        self.m_prodName = prodName
        self.m_version = [int(relV), int(majV), int(minV), int(subminV)]

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetProductVersion (self):
        return self.m_version[0], self.m_version[1], self.m_version[2], self.m_version[3]

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetProductName (self):
        return self.m_prodName

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def DescriptionFileExists (self):
        if not self.m_filePath or not os.path.exists (self.m_filePath):
            return False
        return True

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def HasName (self, repoName):
        return repoName in self.m_repoGuidDict

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetRevision (self, repoName):
        if repoName in self.m_repoGuidDict:
            return self.m_repoGuidDict[repoName].Guid
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllRepoNames (self):
        repoList = list(self.m_repoGuidDict.keys())
        repoList.sort()
        return repoList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetHgLkgStatus (self, repoName):
        if repoName in self.m_repoGuidDict:
            return self.m_repoGuidDict[repoName].FromLkgs
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def RemoveHgRepo (self, repoName):
        if repoName in self.m_repoGuidDict:
            del self.m_repoGuidDict[repoName]

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def HasGitName (self, repoName):
        return repoName in self.m_gitRepoGuidDict

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllGitRepoNames(self):
        repoList = list(self.m_gitRepoGuidDict.keys())
        repoList.sort()
        return repoList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetGitRevision (self, repoName):
        if repoName in self.m_gitRepoGuidDict:
            if  self.m_gitRepoGuidDict[repoName].UseBranch:
                return GIT_BRANCH_TAG_IDENTIFIER+self.m_gitRepoGuidDict[repoName].Branch
            else:
                return self.m_gitRepoGuidDict[repoName].Guid
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetGitLkgStatus (self, repoName):
        if repoName in self.m_gitRepoGuidDict:
            return self.m_gitRepoGuidDict[repoName].FromLkgs
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def RemoveGitRepo (self, repoName):
        if repoName in self.m_gitRepoGuidDict:
            del self.m_gitRepoGuidDict[repoName]

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def HasCvsName (self, repoName):
        return repoName in self.m_repoTagDict

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetCvsTag (self, repoName):
        if repoName in self.m_repoTagDict:
            return self.m_repoTagDict[repoName].Tag
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllCvsNames (self):
        cvsList = list(self.m_repoTagDict.keys())
        cvsList.sort()
        return cvsList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetCvsUrl (self, repoName):
        if repoName in self.m_repoTagDict:
            return self.m_repoTagDict[repoName].Url
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetCvsPath (self, repoName):
        if repoName in self.m_repoTagDict:
            return self.m_repoTagDict[repoName].Path
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def HasRsyncName (self, repoName):
        return repoName in self.m_rsyncRepoDict

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllRsyncNames (self):
        rsyncList = list(self.m_rsyncRepoDict.keys())
        rsyncList.sort()
        return rsyncList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetRsyncPath (self, repoName):
        if repoName in self.m_rsyncRepoDict:
            return self.m_rsyncRepoDict[repoName].Path
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetRsyncUrl (self, repoName):
        if repoName in self.m_rsyncRepoDict:
            return self.m_rsyncRepoDict[repoName].Url
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetRsyncTag (self, repoName):
        if repoName in self.m_rsyncRepoDict:
            return self.m_rsyncRepoDict[repoName].Tag
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def HasSdkSourceName (self, repoName):
        return repoName in self.m_sdkSourceRepoDict

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def _FindNuget (self, packageName, alias):
        packageName = packageName.lower()
        if alias:
            alias = alias.lower()
        for entry in self.m_nugetPackages:
            if packageName == entry.Name.lower() and (alias == None or (entry.Alias and alias == entry.Alias.lower())):
                return entry
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def HasNugetPackageName (self, packageName, alias):
        entry = self._FindNuget (packageName, alias)
        return True if entry else False

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def HasNpmPackageName (self, packageName, version):
        key = NpmPackageDictEntry.MakeKey(packageName, version)
        return key in self.m_npmPackageDict

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def _FindUpack (self, packageName, alias):
        packageName = packageName.lower()
        if alias:
            alias = alias.lower()
        for entry in self.m_upacks:
            if packageName == entry.Name.lower() and (alias == None or (entry.Alias and alias == entry.Alias.lower())):
                return entry
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    # Class:BuildDescription
    #-------------------------------------------------------------------------------------------
    def _FindADOBuildArtifact (self, alias):
        alias = alias.lower()
        for entry in self.m_adoBuildArtifacts:
            if alias == entry.Alias.lower():
                return entry
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def HasUpackName (self, packageName, alias):
        entry = self._FindUpack (packageName, alias)
        return True if entry else False

    #-------------------------------------------------------------------------------------------
    # bsimethod
    # Class:BuildDescription
    #-------------------------------------------------------------------------------------------
    def HasADOBuildArtifactName (self, alias):
        entry = self._FindADOBuildArtifact (alias)
        return True if entry else False

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetUpackVersion (self, packageAlias):
        packageAlias = packageAlias.lower()
        for item in self.m_upacks:
            if item.Name.lower() == packageAlias or (item.Alias and packageAlias == item.Alias.lower()):
                return item.Version
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllBootstrapInfo (self):
        if len(self.m_bootstrapInfo) > 0:
            return list(self.m_bootstrapInfo.values())
        else:
            return []

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetLKGVersion (self, lkgSourceName):
        if lkgSourceName in self.m_lkgSubPartDict:
            lkgSubPartEntry = self.m_lkgSubPartDict[lkgSourceName]
            return (lkgSubPartEntry.ReleaseVersion, lkgSubPartEntry.MajorVersion, lkgSubPartEntry.MinorVersion, lkgSubPartEntry.BuildNumber)
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetLKGType (self, lkgSourceName):
        if lkgSourceName in self.m_lkgSubPartDict:
            return self.m_lkgSubPartDict[lkgSourceName].LKGType
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetLKGUrl (self, lkgSourceName):
        if lkgSourceName in self.m_lkgSubPartDict:
            return self.m_lkgSubPartDict[lkgSourceName].Url
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetSdkSourceVersion (self, sdkName):
        if sdkName in self.m_sdkSourceRepoDict:
            return self.m_sdkSourceRepoDict[sdkName].Version.split('-')
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetSdkSourceVersionString (self, sdkName):
        if sdkName in self.m_sdkSourceRepoDict:
            return self.m_sdkSourceRepoDict[sdkName].Version
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetSdkSourceSdkName (self, sdkName):
        if sdkName in self.m_sdkSourceRepoDict:
            return self.m_sdkSourceRepoDict[sdkName].SdkName
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetSdkSourcePrgName (self, sdkName):
        if sdkName in self.m_sdkSourceRepoDict:
            return self.m_sdkSourceRepoDict[sdkName].PrgOutputDir
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def _GetNugetPackage(self, pkgName):
        pkgName = pkgName.lower()
        for np in self.m_nugetPackages:
            if np.Name.lower() == pkgName or (np.Alias and np.Alias.lower() == pkgName):
                return np
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetNugetVersionString(self, pkgName):
        pkg = self._GetNugetPackage (pkgName)
        if pkg:
            return pkg.Version
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetNugetUrl(self, pkgName):
        pkg = self._GetNugetPackage (pkgName)
        if pkg:
            return pkg.Url
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetNugetAlias(self, pkgName):
        pkg = self._GetNugetPackage (pkgName)
        if pkg:
            return pkg.Alias
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetNpmData(self, pkgString):
        if pkgString in self.m_npmPackageDict:
            return self.m_npmPackageDict[pkgString].Name, self.m_npmPackageDict[pkgString].Version, self.m_npmPackageDict[pkgString].Url
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetBundlePath (self, bundleName):
        if bundleName.lower() in self.m_bundles:
            return self.m_bundles[bundleName.lower()].Path
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetBundleEntry (self, bundleName):
        if bundleName.lower() in self.m_bundles:
            return self.m_bundles[bundleName.lower()]
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetUnsavedLkgs (self, ulName):
        if ulName.lower() in self.m_unsavedLkgs:
            return self.m_unsavedLkgs[ulName.lower()]
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetSubPartLKGSourceNames (self):
        lkgSourceList = list(self.m_lkgSubPartDict.keys())
        lkgSourceList.sort()
        return lkgSourceList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllSdkSourceNames (self):
        nameList = list(self.m_sdkSourceRepoDict.keys())
        nameList.sort()
        return nameList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllNugetPackageNames (self):
        nameList = [item.Alias if item.Alias else item.Name for item in self.m_nugetPackages]
        nameList.sort()
        return nameList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllNpmPackageNames (self):
        nameList = list(self.m_npmPackageDict.keys())
        nameList.sort()
        return nameList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllUpacks (self):
        return [(pkg.Name, pkg.Alias, pkg.Version, pkg.Url, pkg.Feed) for pkg in sorted(self.m_upacks)]

    #-------------------------------------------------------------------------------------------
    # bsimethod
    # Class:BuildDescription
    #-------------------------------------------------------------------------------------------
    def GetAllADOBuildArtifacts (self):
        return [(artifact.Alias, artifact.Name, artifact.ADOBuildId, artifact.DefinitionId, artifact.Project, artifact.Organization) for artifact in sorted(self.m_adoBuildArtifacts)]

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllBundles (self):
        nameList = list(self.m_bundles.keys())
        nameList.sort()
        return nameList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllUnsavedLkgs (self):
        nameList = list(self.m_unsavedLkgs.keys())
        nameList.sort()
        return nameList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllBuiltContexts (self):
        return sorted(self.m_usedContexts)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetUrl (self, repoName):
        repoName = repoName.lower()
        if repoName in self.m_repoGuidDict:
            return self.m_repoGuidDict[repoName].Url
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetGitUrl (self, repoName):
        repoName = repoName.lower()
        if repoName in self.m_gitRepoGuidDict:
            return self.m_gitRepoGuidDict[repoName].Url
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetFromLKG (self, repoName):
        repoName = repoName.lower()
        if repoName in self.m_repoGuidDict:
            return self.m_repoGuidDict[repoName].FromLkgs
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetStrategy (self):
        return self.m_strategyName

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddEntry (self, repoName, guid, repoUrl, fromLKG=False):
        if repoName in self.m_repoGuidDict:
            msg = "Hg repo '" + repoName + "' already exists in Build Description.  Try running 'bb troubleshoot'."
            raise BuildDescriptionError (msg)

        self.UpdateEntry (repoName, guid, repoUrl, fromLKG)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddGitEntry (self, repoName, guid, repoUrl, fromLKG=False):
        if repoName in self.m_gitRepoGuidDict:
            msg = "Git repo '" + repoName + "' already exists in Build Description. Try running 'bb troubleshoot'."
            raise BuildDescriptionError (msg)

        self.UpdateGitEntry(repoName, guid, repoUrl, fromLKG)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddLkgMapEntry (self, shortDescriptorName, prgOutputDir):
        # This is for nested lkgs. When we have an lkg in an lkg we need to specify which lkg it came from (Determined from PrgOutputDir.)

        # lower case as key - store original case - if incoming is not lower case, replace old case.
        lcShort = shortDescriptorName.lower()
        if lcShort in self.m_lkgMapEntries:
            if self.m_lkgMapEntries[lcShort][1].lower () != prgOutputDir.lower():
                msg = "Error: Cannot add LkgMapEntry to LkgMap. '{0}' is not unique and is looking at two PrgOutputDirs: '{1}' and '{2}'."
                raise BuildDescriptionError (msg.format (shortDescriptorName, self.m_lkgMapEntries[lcShort][1], prgOutputDir))
            else:
                if shortDescriptorName != lcShort:
                    self.m_lkgMapEntries[lcShort] = (shortDescriptorName, self.m_lkgMapEntries[lcShort][1])
                return

        self.m_lkgMapEntries[lcShort] = (shortDescriptorName, prgOutputDir)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateLkgMapEntry (self, shortDescriptorName, prgOutputDir):
        # Replace an existing entry if needed, under the assumption that getting it from the top is better.
        #   This may still fail in our split MstnAppData nightmare.

        lcShort = shortDescriptorName.lower()
        if lcShort in self.m_lkgMapEntries:
            self.m_lkgMapEntries[lcShort] = (shortDescriptorName, prgOutputDir)
        else:
            self.AddLkgMapEntry (shortDescriptorName, prgOutputDir)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetLkgMapEntry (self, shortDescriptorName):
        lcShort = shortDescriptorName.lower()
        if lcShort in self.m_lkgMapEntries:
            return self.m_lkgMapEntries[lcShort]

        return None, None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetAllLkgMapEntryNames (self):
        nameList = list(self.m_lkgMapEntries.keys())
        nameList.sort()
        return nameList

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def FindLKGSourceForLkgMapEntry (self, nameToFind):
        nameToFind = nameToFind.lower()
        # Since PRG top-level parts are different, if possible just search by partfile name
        if ':' in nameToFind:
            nameToFind = nameToFind.split(':')[0] + ':*'

        for key in self.m_lkgMapEntries:
            shortNameEntry, prgOutputDir = self.m_lkgMapEntries[key]

            if fnmatch.fnmatch (shortNameEntry.lower(), nameToFind):
                return prgOutputDir
        return None

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddCvsEntry (self, repoName, tag, repoUrl, path):
        if repoName in self.m_repoTagDict:
            msg = "CVS repo '" + repoName + "' already exists in Build Description.  Try running 'bb troubleshoot'."
            raise BuildDescriptionError (msg)

        self.UpdateCvsEntry (repoName, tag, repoUrl, path)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddRsyncEntry (self, repoName, tag, repoUrl, path):
        if repoName in self.m_rsyncRepoDict:
            msg = "Rsync repo '" + repoName + "' already exists in Build Description.  Try running 'bb troubleshoot'."
            raise BuildDescriptionError (msg)

        self.UpdateRsyncEntry (repoName, tag, repoUrl, path)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddSdkSourceEntry (self, repoName, version, prgName, sdkName):
        if repoName in self.m_sdkSourceRepoDict:
            msg = "SdkSource '" + repoName + "' already exists in Build Description.  Try running 'bb troubleshoot'."
            raise BuildDescriptionError (msg)

        self.UpdateSdkSourceEntry (repoName, version, prgName, sdkName)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddNugetPackageEntry (self, packageName, alias, packageUrl, version):
        entry = self._FindNuget (packageName, alias)
        if entry:
            msg = "NugetPackage '" + packageName + "' already exists in Build Description.  Try running 'bb troubleshoot'."
            raise BuildDescriptionError (msg)

        self.UpdateNugetPackageEntry (packageName, alias, packageUrl, version)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddNugetLicenseEntry (self, packageName, version, homepage, spdx, licenseUrl, pkgCopyright, subpackageName = None, subpackageVersion = None):
        entry = PackageLicenseEntry (packageName, version, homepage, spdx, licenseUrl, pkgCopyright, 'nuget', subpackageName, subpackageVersion)
        if entry in self.m_nugetPackageLicenses:
            return  # It's not unlikely to have multiples of the same license. 

        self.m_nugetPackageLicenses.append(entry)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddNpmPackageEntry (self, packageName, packageUrl, version, dev):
        # these have to be unique by name and version. Npm does some wild nesting.
        key = NpmPackageDictEntry.MakeKey(packageName, version)
        if key in self.m_npmPackageDict:
            msg = "NpmPackage '{0}' version {1} already exists in Build Description.".format (packageName, version)
            raise BuildDescriptionError (msg)

        self.UpdateNpmPackageEntry (packageName, packageUrl, version, dev)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddNpmLicenseEntry (self, packageName, version, homepage, spdx, licenseUrl, pkgCopyright, subpackageName = None, subpackageVersion = None):
        entry = PackageLicenseEntry (packageName, version, homepage, spdx, licenseUrl, pkgCopyright, 'npm', subpackageName, subpackageVersion)
        if entry in self.m_npmPackageLicenses:
            msg = "NpmPackage '{0}' version {1} {2}license already in the Build Description.".format (packageName, version, 'with subpackage: \'{0}\' {1} '.format(subpackageName, subpackageVersion) if subpackageName else '')
            raise BuildDescriptionError (msg)

        self.m_npmPackageLicenses.append(entry)

    #-------------------------------------------------------------------------------------------
    # bsiclass
    #-------------------------------------------------------------------------------------------
    def AddCreatedPackageEntry (self, name, version, pkgType, url):
        key = CreatedPackageEntry.MakeKey(name, version)
        if key in self.m_createdPackages:
            raise BuildDescriptionError ("Created Package '{0}' version {1} type {2} already exists in Build Description.".format (name, version, pkgType))

        self.UpdateCreatedPackageEntry (name, version, pkgType, url)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddUpackEntry (self, packageName, alias, version, url, feed):
        entry = UpackDictEntry (packageName, alias, version, url, feed)
        if entry in self.m_upacks:
            raise BuildDescriptionError ("Upack '{0}' version {1} already in the Build Description.".format (packageName, version))

        self.m_upacks.add (entry)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    # Class:BuildDescription
    #-------------------------------------------------------------------------------------------
    def AddAdoBuildArtifactEntry (self, alias, name, adoBuildId, definitionId, project, organization):
        entry = ADOBuildArtifactDictEntry(alias, name, adoBuildId, definitionId, project, organization)
        if entry in self.m_adoBuildArtifacts:
            raise BuildDescriptionError ("Azure Devops Build Artifact '{0}' with alias {1} already in the Build Description.".format (name, alias))

        self.m_adoBuildArtifacts.add (entry)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddLkgSubPartEntry (self, prgOutputDir, prodName, relV, majV, minV, subminV, lkgType, url):
        self.m_lkgSubPartDict[prgOutputDir] = LKGSubPartDictEntry(prgOutputDir, prodName, relV, majV, minV, subminV, lkgType, url)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddContextEntry (self, context):
        # These are the contexts used by the current part - used later when pulling to a BDF to get the right LKGs for the top-level part
        self.m_usedContexts.add (context)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddBundleEntry (self, name, path, organizationName, project, artifactName, azureBuildId):
        if name.lower() in self.m_bundles:
            msg = "Bundle '{0}' already exists in Build Description.".format (name)
            raise BuildDescriptionError (msg)

        self.UpdateBundleEntry (name, path, organizationName, project, artifactName, azureBuildId)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddBootstrapEntry (self, name, repoType, isPrimary, localDir):
        self.m_bootstrapInfo[name.lower()] = BootstrapInfo (name, repoType, isPrimary, localDir)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def AddUnsavedLkgEntry (self, partId):
        if not partId.lower() in self.m_unsavedLkgs:
            self.UpdateUnsavedLkgEntry (partId)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def RemoveEntry(self, repoName):
        if repoName in self.m_repoGuidDict:
            del self.m_repoGuidDict[repoName]
        else:
            raise BuildDescriptionError ("'" + repoName + "' does not exists in Build Description")
    
    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def RemoveGitEntry(self, repoName):
        if repoName in self.m_gitRepoGuidDict:
            del self.m_gitRepoGuidDict[repoName]
        else:
            raise BuildDescriptionError ("'" + repoName + "' does not exists in Build Description")
    
    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateEntry (self, repoName, guid, repoUrl, fromLKG=False):
        self.m_repoGuidDict[repoName] = RepoGuidDictEntry (repoName, guid, repoUrl, fromLKG)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateGitEntry (self, repoName, guid, repoUrl, fromLKG=False):
        self.m_gitRepoGuidDict[repoName] = GitRepoGuidDictEntry (repoName, guid, repoUrl, fromLKG)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def SetGitBranchInformation (self, repoName, branchName, useBranch):
        self.m_gitRepoGuidDict[repoName].Branch = branchName
        self.m_gitRepoGuidDict[repoName].UseBranch = useBranch

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetGitBranchInformation (self, repoName):
        return self.m_gitRepoGuidDict[repoName].Branch, self.m_gitRepoGuidDict[repoName].UseBranch

    #-------------------------------------------------------------------------------------------
    # bsiclass
    #-------------------------------------------------------------------------------------------
    def UpdateCreatedPackageEntry(self, name, version, pkgType, url):
        key = CreatedPackageEntry.MakeKey(name, version)
        self.m_createdPackages[key] = CreatedPackageEntry(name, version, pkgType, url)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateCvsEntry (self, repoName, tag, repoUrl, path):
        self.m_repoTagDict[repoName] = RepoTagDictEntry (repoName, tag, repoUrl, path)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateRsyncEntry (self, repoName, tag, repoUrl, path):
        self.m_rsyncRepoDict[repoName] = RsyncRepoDictEntry (repoName, tag, repoUrl, path)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateSdkSourceEntry (self, repoName, version, prgName, sdkName):
        self.m_sdkSourceRepoDict[repoName] = SdkSourceDictEntry (repoName, version, prgName, sdkName)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateNugetPackageEntry (self, packageName, alias, packageUrl, version):
        entry = self._FindNuget (packageName, alias)
        newEntry = NugetPackageDictEntry (packageName, alias, packageUrl, version)
        if entry:
            self.m_nugetPackages.remove (entry)
        self.m_nugetPackages.add (newEntry)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateNpmPackageEntry (self, packageName, packageUrl, version, dev):
        self.m_npmPackageDict[NpmPackageDictEntry.MakeKey(packageName, version)] = NpmPackageDictEntry (packageName, packageUrl, version, dev)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateBundleEntry (self, name, path, organizationName, project, artifactName, azureBuildId):
        self.m_bundles[name.lower()] = BundleEntry (name, path, organizationName, project, artifactName, azureBuildId)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateUnsavedLkgEntry (self, partId):
        self.m_unsavedLkgs[partId.lower()] = partId

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def UpdateUpackEntry (self, packageName, alias, version, url, feed):
        entry = self._FindUpack (packageName, alias)
        newEntry = UpackDictEntry (packageName, alias, version, url, feed)
        if entry:
            self.m_upacks.remove (entry)
        self.m_upacks.add (newEntry)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    # Class:BuildDescription
    #-------------------------------------------------------------------------------------------
    def UpdateADOBuildArtifactEntry (self, alias, name, adoBuildId, definitionId, project, organization):
        entry = self._FindADOBuildArtifact (alias)
        newEntry = ADOBuildArtifactDictEntry(alias, name, adoBuildId, definitionId, project, organization)
        if entry:
            self.m_adoBuildArtifacts.remove (entry)
        self.m_adoBuildArtifacts.add (newEntry)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def MergeInLkgs (self, lkgGuidHgDict, lkgGuidGitDict, lkgGuidCVSDict, lkgGuidRsyncDict, lkgSubPartDict):
        # We only supply GUIDs from LKGs if we don't have the GUID from a local source repository already
        for key in lkgGuidHgDict:
            if not key in self.m_repoGuidDict:
                self.m_repoGuidDict[key] = RepoGuidDictEntry (key, lkgGuidHgDict[key][0], lkgGuidHgDict[key][1], True)

        for key in lkgGuidGitDict:
            if not key in self.m_gitRepoGuidDict:
                self.m_gitRepoGuidDict[key] = GitRepoGuidDictEntry (key, lkgGuidGitDict[key][0], lkgGuidGitDict[key][1], True)

        for key in lkgGuidCVSDict:
            if not key in self.m_repoTagDict:
                self.m_repoTagDict[key] = RepoTagDictEntry (key, lkgGuidCVSDict[key][0], lkgGuidCVSDict[key][1], lkgGuidCVSDict[key][2])

        for key in lkgGuidRsyncDict:
            if not key in self.m_rsyncRepoDict:
                self.m_rsyncRepoDict[key] = RsyncRepoDictEntry (key, lkgGuidRsyncDict[key][1], lkgGuidRsyncDict[key][2], lkgGuidRsyncDict[key][3])

        self.m_lkgSubPartDict = lkgSubPartDict.copy()

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def ReadFromFile (self, fileName=None):
        path = fileName or self.m_filePath
        if None == path:
            return 0, "Build Description is not backed by a file path"
        if not os.path.exists (path):
            return 1, "Can't read from Build Description file '{0}': file not found".format(path)

        bdrFile = open (path, "rt")
        firstLine = bdrFile.readline()
        bdrFile.close ()

        if '<' in firstLine and '>' in firstLine:
            return self.ReadFromFileXML(path)
        elif '{' in firstLine:
            return self.ReadFromFileJSON(path)
        else:
            return self.ReadFromFileOldStyle (path)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def ReadFromFileOldStyle (self, path):
        self.m_repoGuidDict.clear()

        revListFile = open (path, "rt")
        for line in revListFile:
            line = line.strip()
            line = line[:line.index('#')] if '#' in line else line  # allow '#' for comments
            if "" == line: 
                continue

            repoName, revision, remoteUrl = [token.strip() for token in line.split(', ')]
            self.AddEntry (repoName.lower(), revision, remoteUrl)

        return 0, "Read configuration from {0}".format (path)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def ReadFromFileJSON(self, path):
        with open(path, "rt") as revListFile:
            status = self.ReadFromJSON(revListFile.read())
        
        if 0 == status[0]:
            return 0, "Read configuration from {0}".format(path)
        else:
            return status[0], path + '\n' + status[1]

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def __GetDomElements (self, dom, nameToFind):
        elems = []
        for child in dom.childNodes:
            if child.nodeType != child.ELEMENT_NODE:
                continue
            if child.nodeName == nameToFind:
                elems.append(child)

        return elems

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def ReadFromDom (self, bdescDom):
        self.m_repoGuidDict.clear()
        self.m_gitRepoGuidDict.clear()

        bdNode = self.__GetDomElements (bdescDom, "BuildDescription")
        if len (bdNode) != 1:
            return 1, "There must be 1 BuildDescription node in Build Description file"
        bdNode = bdNode[0]

        #  Strategy
        stratNode = self.__GetDomElements(bdNode, "Strategy")
        if len(stratNode) == 1:
            self.m_strategyName = stratNode[0].getAttribute ("Name")

        #  Stream 
        streamNode = self.__GetDomElements(bdNode, "Stream")
        if len(streamNode) == 1:
            self.m_streamName = streamNode[0].getAttribute ("Name")

        #  PrgOutputDir
        # NOTE: Remove this in a few years, use the attribute on the Product version instead.
        prgOutDirElm = self.__GetDomElements(bdNode, "PrgOutputDir")
        prgOutDirName = "" 
        if len(prgOutDirElm) == 1:
            prgOutDirName = stratNode[0].getAttribute ("Name")

        #  Product name and version
        verElm = self.__GetDomElements(bdNode, "Product")
        if len(verElm) == 1:
            self.m_prodName = verElm[0].getAttribute ("Name")
            self.m_version[0] = int(verElm[0].getAttribute ("ReleaseVersion"))
            self.m_version[1] = int(verElm[0].getAttribute ("MajorVersion"))
            self.m_version[2] = int(verElm[0].getAttribute ("MinorVersion"))
            self.m_version[3] = int(verElm[0].getAttribute ("BuildNumber"))
            if 0 < len (verElm[0].getAttribute ("PrgOutputDir")):
                prgOutDirName = verElm[0].getAttribute ("PrgOutputDir")
            self.m_prgProductId = int(verElm[0].getAttribute ("PrgProductId") if verElm[0].getAttribute ("PrgProductId") else 0)

            if 0 < len (verElm[0].getAttribute ("BuildType")):
                self.m_buildType = verElm[0].getAttribute ("BuildType")

            if 0 < len (verElm[0].getAttribute ("BuildTimeISO")):
                self.m_buildTimeIso = str(verElm[0].getAttribute ("BuildTimeISO"))

        self.m_PRGDirName = prgOutDirName

        adoBuildPropertiesElm = self.__GetDomElements(bdNode, "ADOBuildProperties")
        if len(adoBuildPropertiesElm) == 1:
            self.m_adoBuildProperties = ADOBuildProperties (
                adoBuildPropertiesElm[0].getAttribute ("AgentName"),
                adoBuildPropertiesElm[0].getAttribute ("BuildNumber"),
                adoBuildPropertiesElm[0].getAttribute ("BuildUri"),
                adoBuildPropertiesElm[0].getAttribute ("BuildDefinitionName"),
                adoBuildPropertiesElm[0].getAttribute ("BuildDefinitionId"),
                adoBuildPropertiesElm[0].getAttribute ("BuildQueuedBy"),
                adoBuildPropertiesElm[0].getAttribute ("BuildReason"),
                adoBuildPropertiesElm[0].getAttribute ("BuildRequestedFor"),
                adoBuildPropertiesElm[0].getAttribute ("BuildSourceBranchName"),
                adoBuildPropertiesElm[0].getAttribute ("ADOBuildId"),
                adoBuildPropertiesElm[0].getAttribute ("ProjectId"),
                adoBuildPropertiesElm[0].getAttribute ("ProjectName"),
                adoBuildPropertiesElm[0].getAttribute ("OrganizationName"),
                adoBuildPropertiesElm[0].getAttribute ("OrganizationId")
                )

        # Repos
        repoListNode = self.__GetDomElements (bdNode, "Repositories")
        if len (repoListNode) != 1:
            return 1, "There must be 1 'Repositories' node in Build Description file"

        repoList = self.__GetDomElements (repoListNode[0], "Repository")
        for curElm in repoList:
            repoName = curElm.getAttribute ("Name")
            guid = curElm.getAttribute ("Guid")
            repoUrl = curElm.getAttribute ("Url")
            fromLKG = curElm.getAttribute ("FromLkgs") == "True"
            self.m_repoGuidDict[repoName.lower()] = RepoGuidDictEntry (repoName, guid, repoUrl, fromLKG)


        # LKG's - Optional
        lkgListNode = self.__GetDomElements (bdNode, "LkgSubParts")
        if len (lkgListNode) == 0:
            pass
        elif len (lkgListNode) == 1:
            lkgList = self.__GetDomElements (lkgListNode[0], "LkgSubPart")
            for curElm in lkgList:
                prodName = curElm.getAttribute ("Name")
                prgOutputDir = curElm.getAttribute ("PrgOutputDir")
                relV = curElm.getAttribute ("ReleaseVersion")
                majV = curElm.getAttribute ("MajorVersion")
                minV = curElm.getAttribute ("MinorVersion")
                subminV = curElm.getAttribute ("BuildNumber")
                lkgType = curElm.getAttribute ("LKGType")
                if lkgType is None or lkgType == "":
                    lkgType = 'fileshare'
                url = curElm.getAttribute ("Url")
                if url is None or url == "":
                    url = "\\\\builds\\prgbuilds-readonly\\LKGOutput\\{}\\{}\\$(platform)".format(prgOutputDir, getDirStrForVersion([relV, majV, minV, subminV]))

                lkgType, url = ProcessLKGTypeAndUrlForEnvironment(lkgType, url)

                self.AddLkgSubPartEntry(prgOutputDir, prodName, relV, majV, minV, subminV, lkgType, url)
        else:
            return 1, "There cannot be more than 1 'LkgSubParts' node in Build Description file"

        # LKG part map - Optional
        lkgPartMapNode = self.__GetDomElements (bdNode, "LkgPartMap")
        if len (lkgPartMapNode) == 0:
            pass
        elif len (lkgPartMapNode) == 1:
            lkgList = self.__GetDomElements (lkgPartMapNode[0], "LkgMapEntry")
            for curElm in lkgList:
                shortDescriptorName = curElm.getAttribute ("Name")
                prgOutputDir = curElm.getAttribute ("PrgOutputDir")
                self.AddLkgMapEntry (shortDescriptorName, prgOutputDir)
        else:
            return 1, "There cannot be more than 1 'LkgPartMap' node in Build Description file"

        # Context list - Optional
        includedContextNode = self.__GetDomElements (bdNode, "BuiltContexts")
        if len (includedContextNode) == 0:
            pass
        elif len (includedContextNode) == 1:
            contextList = self.__GetDomElements (includedContextNode[0], "Context")
            for curElm in contextList:
                contextName = curElm.getAttribute ("Name")
                self.AddContextEntry (contextName)
        else:
            return 1, "There cannot be more than 1 'BuiltContexts' node in Build Description file"

        # CVS-based repositories
        cvsListNode = self.__GetDomElements (bdNode, "CvsRepositories")
        if len (cvsListNode) == 0:
            pass
        elif len (cvsListNode) == 1:
            cvsList = self.__GetDomElements (cvsListNode[0], "CvsRepository")
            for curElm in cvsList:
                repoName = curElm.getAttribute ("Name")
                tag = curElm.getAttribute ("Tag")
                repoUrl = curElm.getAttribute ("Url")
                path = curElm.getAttribute ("Path")
                self.m_repoTagDict[repoName] = RepoTagDictEntry (repoName, tag, repoUrl, path)
        else:
            return 1, "There cannot be more than 1 'CvsRepositories' node in Build Description file"

        # rsync-based repositories
        cvsListNode = self.__GetDomElements (bdNode, "RsyncRepositories")
        if len (cvsListNode) == 0:
            pass
        elif len (cvsListNode) == 1:
            cvsList = self.__GetDomElements (cvsListNode[0], "RsyncRepository")
            for curElm in cvsList:
                repoName = curElm.getAttribute ("Name")
                tag = curElm.getAttribute ("Tag")
                repoUrl = curElm.getAttribute ("Url")
                repoPath = curElm.getAttribute ("Path")
                self.m_rsyncRepoDict[repoName] = RsyncRepoDictEntry (repoName, tag, repoUrl, repoPath)
        else:
            return 1, "There cannot be more than 1 'RsyncRepositories' node in Build Description file"

        # Git Repositories
        gitListNode = self.__GetDomElements (bdNode, "GitRepositories")
        if len(gitListNode) == 0:
            pass
        elif len(gitListNode) == 1:
            gitRepoList = self.__GetDomElements(gitListNode[0], "GitRepository")
            for curElm in gitRepoList:
                repoName = curElm.getAttribute ("Name")
                guid = curElm.getAttribute ("Guid")
                repoUrl = curElm.getAttribute ("Url")
                fromLKG = curElm.getAttribute ("FromLkgs") == "True"
                self.m_gitRepoGuidDict[repoName.lower()] = GitRepoGuidDictEntry (repoName, guid, repoUrl, fromLKG)
                branch = curElm.getAttribute ("Branch")
                if branch == "": branch = None
                useBranch = curElm.getAttribute ("UseBranch") == "True"
                self.m_gitRepoGuidDict[repoName.lower()].Branch = branch
                self.m_gitRepoGuidDict[repoName.lower()].UseBranch = useBranch
        else:
            return 1, "There cannot be more than 1 'GitRepositories' node in the Build Description file"

        # Sdk Sources
        cvsListNode = self.__GetDomElements (bdNode, "SdkSources")
        if len (cvsListNode) == 0:
            pass
        elif len (cvsListNode) == 1:
            cvsList = self.__GetDomElements (cvsListNode[0], "SdkSource")
            for curElm in cvsList:
                repoName = curElm.getAttribute ("Name")
                version = curElm.getAttribute ("Version")
                
                # We changed what is stored in the BDF. If it's the old format then split the path up
                repoPath = curElm.getAttribute ("Path")
                if repoPath:
                    sdkRe = re.compile (r'[_\w\-\\]+lkgoutput\\([_\w\-]+)[_\w\-\\]+\\([\w\-_]+)$')
                    match = sdkRe.match (repoPath)
                    if match:
                        prgName = match.group(1)
                        sdkName = match.group(2)
                    else:
                        prgName = None
                        sdkName = None
                else:
                    prgName = curElm.getAttribute ("PrgOutputDir")
                    sdkName = curElm.getAttribute ("SdkName")
                    
                self.m_sdkSourceRepoDict[repoName] = SdkSourceDictEntry (repoName, version, prgName, sdkName)
        else:
            return 1, "There cannot be more than 1 'SdkSources' node in Build Description file"

        # Nuget Packages
        cvsListNode = self.__GetDomElements (bdNode, "NugetPackages")
        if len (cvsListNode) == 0:
            pass
        elif len (cvsListNode) == 1:
            cvsList = self.__GetDomElements (cvsListNode[0], "NugetPackage")
            for curElm in cvsList:
                packageName = curElm.getAttribute ("Name")
                alias = curElm.getAttribute ("Alias") if curElm.hasAttribute ("Alias") else None
                version = curElm.getAttribute ("Version")
                packageUrl = curElm.getAttribute ("Url")
                self.m_nugetPackages.add (NugetPackageDictEntry (packageName, alias, packageUrl, version))
        else:
            return 1, "There cannot be more than 1 'NugetPackages' node in Build Description file"

        # Npm Packages
        cvsListNode = self.__GetDomElements (bdNode, "NpmPackages")
        if len (cvsListNode) == 0:
            pass
        elif len (cvsListNode) == 1:
            cvsList = self.__GetDomElements (cvsListNode[0], "NpmPackage")
            for curElm in cvsList:
                packageName = curElm.getAttribute ("Name")
                version = curElm.getAttribute ("Version")
                packageUrl = curElm.getAttribute ("Url")
                dev = curElm.getAttribute ("Dev") == 'True'
                self.m_npmPackageDict[NpmPackageDictEntry.MakeKey(packageName, version)] = NpmPackageDictEntry (packageName, packageUrl, version, dev)
        else:
            return 1, "There cannot be more than 1 'NpmPackages' node in Build Description file"

        # Universal Packages
        cvsListNode = self.__GetDomElements (bdNode, "UniversalPackages")
        if len (cvsListNode) == 0:
            pass
        elif len (cvsListNode) == 1:
            cvsList = self.__GetDomElements (cvsListNode[0], "UniversalPackage")
            for curElm in cvsList:
                packageName = curElm.getAttribute ("Name")
                alias = curElm.getAttribute ("Alias") if curElm.hasAttribute ("Alias") else None
                version = curElm.getAttribute ("Version")
                packageUrl = curElm.getAttribute ("Url")
                packageFeed = curElm.getAttribute ("Feed")
                self.m_upacks.add (UpackDictEntry (packageName, alias, version, packageUrl, packageFeed))
        else:
            return 1, "There cannot be more than 1 'UniversalPackages' node in Build Description file"

        # Azure Devops Build artifacts
        adoArtifactListNode = self.__GetDomElements (bdNode, "ADOBuildArtifacts")
        if len (adoArtifactListNode) == 0:
            pass
        elif len (adoArtifactListNode) == 1:
            artifactList = self.__GetDomElements (adoArtifactListNode[0], "ADOBuildArtifact")
            for curElm in artifactList:
                name = curElm.getAttribute ("Name")
                alias = curElm.getAttribute ("Alias")
                adoBuildId = curElm.getAttribute ("ADOBuildId")
                definitionId = curElm.getAttribute ("DefinitionId")
                project = curElm.getAttribute ("Project")
                organization = curElm.getAttribute ("Organization")
                self.m_adoBuildArtifacts.add (ADOBuildArtifactDictEntry(alias, name, adoBuildId, definitionId, project, organization))
        else:
            return 1, "There cannot be more than 1 'ADOBuildArtifacts' node in Build Description file"

        # Created Packages
        packListNode = self.__GetDomElements(bdNode, "CreatedPackages")
        if len (packListNode) == 0:
            pass
        elif len (packListNode) == 1:
            pkg = self.__GetDomElements (packListNode[0], "CreatedPackage")
            for curElm in pkg:
                name = curElm.getAttribute ("Name")
                version = curElm.getAttribute ("Version")
                pkgtype = curElm.getAttribute ("Type")
                url = curElm.getAttribute ("Url")
                self.m_createdPackages[CreatedPackageEntry.MakeKey(name, version)] = CreatedPackageEntry (name, version, pkgtype, url)
        else:
            return 1, "There cannot be more than 1 'CreatedPackages' node in Build Description file"

        # Package Licenses
        packLicListNode = self.__GetDomElements(bdNode, "PackageLicenses")
        if len (packLicListNode) == 0:
            pass
        elif len (packLicListNode) == 1:
            pkg = self.__GetDomElements (packLicListNode[0], "PackageLicense")
            for curElm in pkg:
                name = curElm.getAttribute ("PackageName")
                version = curElm.getAttribute ("Version")
                homepage = curElm.getAttribute ("PackageHomePage")
                licName = curElm.getAttribute ("LicenseName")
                licLink = curElm.getAttribute ("LicenseLink")
                pkgCopyright = curElm.getAttribute ("Copyright")
                pkgtype = curElm.getAttribute ("Type")
                subpackageName = curElm.getAttribute ("SubpackageName")  if curElm.hasAttribute("SubpackageName") else ''
                subpackageVersion = curElm.getAttribute ("SubpackageVersion")  if curElm.hasAttribute("SubpackageVersion") else ''
                pkgLicense = PackageLicenseEntry(name, version, homepage, licName, licLink, pkgCopyright, pkgtype, subpackageName, subpackageVersion)
                if pkgtype.lower() == 'npm':
                    self.m_npmPackageLicenses.append(pkgLicense)
                else:
                    self.m_nugetPackageLicenses.append(pkgLicense)
        else:
            return 1, "There cannot be more than 1 'CreatedPackages' node in Build Description file"

        # Bundles
        bundelListNode = self.__GetDomElements (bdNode, "Bundles")
        if len (bundelListNode) == 0:
            pass
        elif len (bundelListNode) == 1:
            bundleList = self.__GetDomElements (bundelListNode[0], "Bundle")
            for curElm in bundleList:
                name = curElm.getAttribute ("Name")
                path = curElm.getAttribute ("Path")
                organizationName = curElm.getAttribute("OrganizationName")
                project = curElm.getAttribute("Project")
                artifactName = curElm.getAttribute("ArtifactName")
                azureBuildId = curElm.getAttribute("AzureBuildId")
                self.m_bundles[name.lower()] = BundleEntry (name, path, organizationName, project, artifactName, azureBuildId)
        else:
            return 1, "There cannot be more than 1 'Bundles' node in Build Description file"

        # Unsaved LKGs
        unsavedLkgListNode = self.__GetDomElements (bdNode, "UnsavedLKGs")
        if len (unsavedLkgListNode) == 0:
            pass
        elif len (unsavedLkgListNode) == 1:
            itemList = self.__GetDomElements (unsavedLkgListNode[0], "UnsavedLKG")
            for curElm in itemList:
                lkgName = curElm.getAttribute ("Name")
                self.m_unsavedLkgs[lkgName.lower()] = lkgName
        else:
            return 1, "There cannot be more than 1 'UnsavedLKGs' node in Build Description file"

        # Environment Variables; added along the way
        envVarNode = self.__GetDomElements (bdNode, "AsBuiltEnvironment")
        if len (envVarNode) == 0:
            pass
        elif len (envVarNode) == 1:
            self.m_writeEnvironment = True
            
            envList = self.__GetDomElements (envVarNode[0], "Env")
            for curElm in envList:
                name = curElm.getAttribute ("Name")
                value = curElm.getAttribute ("Value")
                self.m_environment[name] = value
        else:
            return 1, "There cannot be more than 1 'AsBuiltEnvironment' node in Build Description file"

        bdescDom.unlink()  # Recommended by current docs to free doms this way

        #self.Dump()

        return 0, "Read configuration from DOM"

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def ReadFromFileXML (self, path):
        try:
            bdescDom = minidom.parse (path)
        except xml.parsers.expat.ExpatError as errIns:
            return 1, "Unable to read build description from file '{0}' error {1}".format(path, errIns)

        status = self.ReadFromDom (bdescDom)

        if 0 == status[0]:
            return 0, "Read configuration from {0}".format (path)
        else:
            return status[0], path + ' ' + status[1]

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def ReadFromJSON (self, jsonString):
    #takes in json string from a raw jsonstring
        try:
            bdescJson = json.loads(jsonString)
        except Exception as ex:
            return 1, "Error: could not read JSON GET request.\nException:\n{0}".format (ex)

        # Config bdf JSONS will not have this info
        if 'Product' in bdescJson:
            self.m_version[0] = bdescJson["Product"][0]["ReleaseVersion"]
            self.m_version[1] = bdescJson["Product"][0]["MajorVersion"]
            self.m_version[2] = bdescJson["Product"][0]["MinorVersion"]
            self.m_version[3] = bdescJson["Product"][0]["BuildNumber"]

            self.m_PRGDirName = bdescJson["Product"][0]["Name"]
            self.m_streamName = bdescJson["Product"][0]["Stream"]
            self.m_strategyName = bdescJson["Product"][0]["Strategy"]
            self.m_prodName = bdescJson["Product"][0]["TopLevelPartName"]
            self.m_prgProductId = bdescJson["Product"][0]["PrgProductId"] if "PrgProductId" in bdescJson["Product"][0] else 0
            self.m_buildType = bdescJson["Product"][0]["BuildType"] if "BuildType" in bdescJson["Product"][0] else DEFAULT_BUILD_TYPE

        #setting hg repositories
        if "HgRepositories" in bdescJson:
            for hgRepo in bdescJson["HgRepositories"]:
                self.m_repoGuidDict[hgRepo["Name"].lower()] = RepoGuidDictEntry(hgRepo["Name"], hgRepo["Guid"], hgRepo["Url"], hgRepo["FromLkgs"])

        #setting lkg entries
        if "LkgSubParts" in bdescJson:
            for lkgEntry in bdescJson["LkgSubParts"]:
                prodName = lkgEntry["TopLevelPartName"]
                prgOutputDir = lkgEntry["Name"]
                relV = lkgEntry["ReleaseVersion"]
                majV = lkgEntry["MajorVersion"]
                minV = lkgEntry["MinorVersion"]
                subminV = lkgEntry["BuildNumber"]
                lkgType = lkgEntry["LKGType"] if "LKGType" in lkgEntry else None
                if lkgType is None or lkgType == "":
                    lkgType = 'rsync'
                url = lkgEntry["Url"] if "Url" in lkgEntry else None
                if url is None:
                    url = BUILDS_RSYNC + r'\LKGOutput\{}\{}\$(platform)'.format(prgOutputDir, getDirStrForVersion([relV, majV, minV, subminV]))

                lkgType, url = ProcessLKGTypeAndUrlForEnvironment(lkgType, url)
                self.AddLkgSubPartEntry(prgOutputDir, prodName, relV, majV, minV, subminV, lkgType, url)

        #setting lkg part map entries
        if "LkgPartMap" in bdescJson:
            for lkgMap in bdescJson["LkgPartMap"]:
                self.AddLkgMapEntry(lkgMap["PartName"], lkgMap["Name"])

        #setting cvs repositories
        if "CvsRepositories" in bdescJson:
            for cvsRepo in bdescJson["CvsRepositories"]:
                self.m_repoTagDict[cvsRepo["Name"]] = RepoTagDictEntry(cvsRepo["Name"], cvsRepo["Tag"], cvsRepo["Url"], cvsRepo["Path"])

        #setting rsync repositories
        if "RsyncRepositories" in bdescJson:
            for rsyncRepo in bdescJson["RsyncRepositories"]:
                self.m_rsyncRepoDict[rsyncRepo["Name"]] = RsyncRepoDictEntry(rsyncRepo["Name"], rsyncRepo["Tag"], rsyncRepo["Url"], rsyncRepo["Path"])

        if "GitRepositories" in bdescJson:
            for gitRepo in bdescJson["GitRepositories"]:
                self.m_gitRepoGuidDict[gitRepo["Name"]] = GitRepoGuidDictEntry(gitRepo["Name"], gitRepo["Guid"], gitRepo["Url"], gitRepo["FromLkgs"])
                if 'Branch' in gitRepo:
                    self.m_gitRepoGuidDict[gitRepo["Name"]].Branch = gitRepo["Branch"]
                if 'UseBranch' in gitRepo:
                    self.m_gitRepoGuidDict[gitRepo["Name"]].UseBranch = gitRepo["UseBranch"]

        #setting sdk repositories
        if "SdkSources" in bdescJson:
            for sdkRepo in bdescJson["SdkSources"]:
                self.m_sdkSourceRepoDict[sdkRepo["Name"]] = SdkSourceDictEntry(sdkRepo["Name"], sdkRepo["Version"], sdkRepo["PrgOutputDir"], sdkRepo["SdkName"])

        #setting nuget packages
        if "NugetPackages" in bdescJson:
            for pkg in bdescJson["NugetPackages"]:
                alias = pkg["Alias"] if "Alias" in pkg else None
                self.m_nugetPackages.add (NugetPackageDictEntry(pkg["Name"], alias, pkg["Url"], pkg["Version"]))

        #setting npm packages
        if "NpmPackages" in bdescJson:
            for pkg in bdescJson["NpmPackages"]:
                # Usage column values will either be "DEV Only" or Empty String
                self.m_npmPackageDict[NpmPackageDictEntry.MakeKey(pkg["Name"], pkg["Version"])] = NpmPackageDictEntry(pkg["Name"], pkg["Url"], pkg["Version"], "Usage" in pkg.keys() and len(pkg["Usage"]) > 1)

        if "UniversalPackages" in bdescJson:
            for pkg in bdescJson["UniversalPackages"]:
                alias = pkg["Alias"] if "Alias" in pkg else None
                self.m_upacks.add (UpackDictEntry (pkg["Name"], alias, pkg["Version"], pkg["Url"], pkg["Feed"]))

        if "ADOBuildArtifacts" in bdescJson:
            for artifact in bdescJson["ADOBuildArtifacts"]:
                self.m_adoBuildArtifacts.add (ADOBuildArtifactDictEntry(artifact["Alias"], artifact["Name"], artifact["ADOBuildId"], artifact["DefinitionId"], artifact["Project"], artifact["Organization"]))

        # setting created packages
        if "CreatedPackages" in bdescJson:
            for pkg in bdescJson["CreatedPackages"]:
                name = pkg["Name"]
                version = pkg["Version"]
                pkgtype = pkg["Type"]
                url = pkg["Url"]
                self.m_createdPackages[CreatedPackageEntry.MakeKey(name, version)] = CreatedPackageEntry (name, version, pkgtype, url)

        #setting Bundles
        if "Bundles" in bdescJson:
            for pkg in bdescJson["Bundles"]:
                # Usage column values will either be "DEV Only" or Empty String
                self.m_bundles[pkg["Name"].lower()] = BundleEntry (pkg["Name"], pkg["Path"], pkg["OrganizationName"] if "OrganizationName" in pkg else None, pkg["ProjectName"] if "ProjectName" in pkg else None, pkg["ArtifactName"] if "ArtifactName" in pkg else None, pkg["AzureBuildId"] if "AzureBuildId" in pkg else None)

        #setting UnsavedLKGs
        if "UnsavedLKGs" in bdescJson:
            for pkg in bdescJson["UnsavedLKGs"]:
                # Usage column values will either be "DEV Only" or Empty String
                self.m_unsavedLkgs[pkg["Name"].lower()] = pkg["Name"]

        # setting package licenses
        if "PackageLicenses" in bdescJson:
            for pkg in bdescJson["PackageLicenses"]:
                name = pkg["PackageName"]
                version = pkg["Version"]
                homepage = pkg["PackageHomePage"]
                licName = pkg["LicenseName"]
                licLink = pkg["LicenseLink"]
                pkgCopyright = pkg["Copyright"]
                pkgtype = pkg["Type"]
                subpackageName = pkg["SubpackageName"] if "SubpackageName" in pkg else ''
                subpackageVersion = pkg["SubpackageVersion"] if "SubpackageVersion" in pkg else ''
                pkgLicense = PackageLicenseEntry(name, version, homepage, licName, licLink, pkgCopyright, pkgtype, subpackageName, subpackageVersion)
                if pkgtype.lower() == 'npm':
                    self.m_npmPackageLicenses.append(pkgLicense)
                else:
                    self.m_nugetPackageLicenses.append(pkgLicense)

        #setting built context
        if "BuiltContexts" in bdescJson:
            for context in bdescJson["BuiltContexts"]:
                self.AddContextEntry(context["Name"])

        if "Bootstrap" in bdescJson:
            for bootItem in bdescJson["Bootstrap"]:
                self.m_bootstrapInfo[bootItem["Name"].lower()] = BootstrapInfo(bootItem["Name"], bootItem["RepoType"], bootItem["IsPrimary"], bootItem.get("LocalDir", None))

        #setting as built environment & adding buildtime as part of environment (as originally created bdfs were)
        if "AsBuiltEnvironment" in bdescJson:
            self.m_writeEnvironment = True

            if "BuildTimeISO" in bdescJson["Product"][0]:
                self.m_buildTimeIso = bdescJson["Product"][0]["BuildTimeISO"]

            if "BuildTime" in bdescJson["Product"][0]:
                buildTime = bdescJson["Product"][0]["BuildTime"]
                self.m_environment['BUILDTIME'] = buildTime

            for env in bdescJson["AsBuiltEnvironment"]:
                self.m_environment[env["Name"]] = env["Value"]

        return 0, "JSON loaded & parsed successfully"

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteToJSON (self):
        if "BUILDTIME" in self.m_environment:
            buildTime = self.m_environment['BUILDTIME']
        else:
            self.GetEnvirnomentVars()
            buildTime = self.m_environment['BUILDTIME']

        def AppendListOfObjs (jsonObject, catagoryName, dictToAdd):
            jsonObject [catagoryName] = [dictToAdd[repo].__dict__ for repo in sorted(dictToAdd)]

        jsonObject = {}

        prodListDict = {}
        prodListDict['Name'] = self.m_PRGDirName
        prodListDict['ReleaseVersion'] = self.m_version[0]
        prodListDict['MajorVersion'] = self.m_version[1]
        prodListDict['MinorVersion'] = self.m_version[2]
        prodListDict['BuildNumber'] = self.m_version[3]
        prodListDict['Stream'] = self.m_streamName if self.m_streamName else ""
        prodListDict['Strategy'] = self.m_strategyName
        prodListDict['TopLevelPartName'] = self.m_prodName
        if self.m_buildTimeIso:
            prodListDict['BuildTimeISO'] = self.m_buildTimeIso
        prodListDict['BuildTime'] = buildTime
        prodListDict['PrgProductId'] = self.m_prgProductId
        prodListDict['BuildType'] = self.m_buildType
        jsonObject ['Product'] = [prodListDict]

        #Azure DevOps build properties
        if self.m_adoBuildProperties:
            prodADOBuildProperties = {}
            prodADOBuildProperties["AgentName"] = self.m_adoBuildProperties.AgentName
            prodADOBuildProperties["BuildNumber"] = self.m_adoBuildProperties.BuildNumber
            prodADOBuildProperties["BuildUri"] = self.m_adoBuildProperties.BuildUri
            prodADOBuildProperties["BuildDefinitionName"] = self.m_adoBuildProperties.BuildDefinitionName
            prodADOBuildProperties["BuildDefinitionId"] = self.m_adoBuildProperties.BuildDefinitionId
            prodADOBuildProperties["BuildQueuedBy"] = self.m_adoBuildProperties.BuildQueuedBy
            prodADOBuildProperties["BuildReason"] = self.m_adoBuildProperties.BuildReason
            prodADOBuildProperties["BuildRequestedFor"] = self.m_adoBuildProperties.BuildRequestedFor
            prodADOBuildProperties["BuildSourceBranchName"] = self.m_adoBuildProperties.BuildSourceBranchName
            prodADOBuildProperties["ADOBuildId"] = self.m_adoBuildProperties.ADOBuildId
            prodADOBuildProperties["ProjectId"] = self.m_adoBuildProperties.ProjectId
            prodADOBuildProperties["ProjectName"] = self.m_adoBuildProperties.ProjectName
            prodADOBuildProperties["OrganizationName"] = self.m_adoBuildProperties.OrganizationName
            prodADOBuildProperties["OrganizationId"] = self.m_adoBuildProperties.OrganizationId
            jsonObject ['ADOBuildProperties'] = [prodADOBuildProperties]

        jsonObject ['LkgSubParts'] = [x.__dict__ for x in sorted(self.m_lkgSubPartDict.values())]

        lkgPartMapList = []
        consolidatedMap, uniqueEntries = self.CompressLkgMapElements()
        for entry in consolidatedMap:
            lkgPartMapList.append (LkgPartMapItem (consolidatedMap[entry][1], consolidatedMap[entry][0]))
        for item in uniqueEntries:
            lkgPartMapList.append (LkgPartMapItem (item[1], item[0]))
        jsonObject ['LkgPartMap'] = [x.__dict__ for x in sorted(lkgPartMapList)]

        AppendListOfObjs (jsonObject, 'Bundles', self.m_bundles)

        jsonObject ['UnsavedLKGs'] = [{'Name':entry} for entry in sorted(self.m_unsavedLkgs.values())]

        AppendListOfObjs (jsonObject, 'HgRepositories', self.m_repoGuidDict)
        AppendListOfObjs (jsonObject, 'CvsRepositories', self.m_repoTagDict)
        AppendListOfObjs (jsonObject, 'RsyncRepositories', self.m_rsyncRepoDict)
        AppendListOfObjs (jsonObject, 'GitRepositories', self.m_gitRepoGuidDict)
        AppendListOfObjs (jsonObject, 'SdkSources', self.m_sdkSourceRepoDict)
        AppendListOfObjs (jsonObject, 'NpmPackages', self.m_npmPackageDict)
        AppendListOfObjs (jsonObject, 'CreatedPackages', self.m_createdPackages)

        jsonObject['NugetPackages'] = [repo.__dict__ for repo in sorted(self.m_nugetPackages)]
        jsonObject['UniversalPackages'] = [repo.__dict__ for repo in sorted(self.m_upacks)]
        jsonObject['ADOBuildArtifacts'] = [repo.__dict__ for repo in sorted(self.m_adoBuildArtifacts)]

        if self.m_nugetPackageLicenses or self.m_npmPackageLicenses:
            jsonObject ['PackageLicenses'] = [x.__dict__ for x in sorted(self.m_nugetPackageLicenses + self.m_npmPackageLicenses)]

        jsonObject ['BuiltContexts'] = [{'Name':context} for context in sorted(self.m_usedContexts)]

        envList = []
        for env in self.m_environment:
            if env != 'BUILDTIME':
                envList.append (EnvironmentItem(env, self.m_environment[env]))
        jsonObject ['AsBuiltEnvironment'] = [x.__dict__ for x in sorted(envList)]

        AppendListOfObjs (jsonObject, 'Bootstrap', self.m_bootstrapInfo)

#        print json.dumps(jsonObject, sort_keys=True, indent=4)
#        print json.dumps(jsonObject, sort_keys=True, indent=4, separators=(',', ': '))

        return jsonObject

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteToJsonFile (self, fileName, _outputFn):
        try:
            jsonObj = self.WriteToJSON()
            jsonStr = json.dumps (jsonObj, sort_keys=True, indent=2)
            with codecs.open(fileName, mode='w', encoding='utf-8') as jsonFile:
                jsonFile.write (jsonStr)
        except Exception as err:
            return 1, "Error generating Build Description: {0}".format (str(err))

        return 0, "Succeeded"
            
    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetJsonForConfig (self):
        jsonObj = self.WriteToJSON()
        jkeys = list(jsonObj.keys())
        emptySections = set()
        for jk in jkeys:
            if len(jsonObj[jk]) == 0:
                emptySections.add(jk)
        for jk in jkeys:
            if jk in emptySections or jk not in CONFIG_FIELDS:
                del jsonObj[jk]

        return jsonObj

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteBBConfig (self, fileName, _outputFn):
        try:
            jsonObj = self.GetJsonForConfig()
            jsonStr = json.dumps (jsonObj, sort_keys=True, indent=2)
            with codecs.open(fileName, mode='w', encoding='utf-8') as jsonFile:
                jsonFile.write (jsonStr)
        except Exception as err:
            return 1, "Error generating Build Description: {0}".format (str(err))

        return 0, "Succeeded"

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def Display (self, outputFn):
        keylist = list(self.m_repoGuidDict.keys())
        keylist.sort()
        for key in keylist:
            entry = self.m_repoGuidDict[key]
            if outputFn:
                outputFn ('Repository: name={0}, guid={1}, url={2}, fromLKG={3}\n'.format (entry.Name, entry.Guid, entry.Url, repr(entry.FromLkgs)))


    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteRepositoryElements (self, dom, node, outputFn):
        repoElm = dom.createElement ("Repositories")
        node.appendChild (repoElm)

        keylist = list(self.m_repoGuidDict.keys())
        keylist.sort()
        for key in keylist:
            entry = self.m_repoGuidDict[key]
            if outputFn:
                outputFn ('Repository: name={0}, guid={1}, url={2}, fromLKG={3}\n'.format (entry.Name, entry.Guid, entry.Url, repr(entry.FromLkgs)))

            curElm = dom.createElement ("Repository")
            curElm.setAttribute ("Name", entry.Name)
            curElm.setAttribute ("Guid", entry.Guid)
            curElm.setAttribute ("Url", entry.Url)
            curElm.setAttribute ("FromLkgs", repr(entry.FromLkgs))
            repoElm.appendChild (curElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteGitRepositoryElements (self, dom, node, outputFn):
        if len (self.m_gitRepoGuidDict) == 0:
            return

        repoElm = dom.createElement ("GitRepositories")
        node.appendChild (repoElm)

        keylist = list(self.m_gitRepoGuidDict.keys())
        keylist.sort()
        for key in keylist:
            entry = self.m_gitRepoGuidDict[key]
            if outputFn:
                outputFn ('Repository: name={0}, guid={1}, url={2}, fromLKG={3}\n'.format (entry.Name, entry.Guid, entry.Url, repr(entry.FromLkgs)))

            curElm = dom.createElement ("GitRepository")
            curElm.setAttribute ("Name", entry.Name)
            curElm.setAttribute ("Guid", entry.Guid)
            curElm.setAttribute ("Url", entry.Url)
            curElm.setAttribute ("FromLkgs", repr(entry.FromLkgs))
            curElm.setAttribute ("Branch", entry.Branch)
            curElm.setAttribute ("UseBranch", repr(entry.UseBranch))
            repoElm.appendChild (curElm)
            
    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def isReleased(self, PrgOutputDir, version):
        fileName = GetFileNameFromVersion(PrgOutputDir, version)
        srcRoot = os.environ.get ("SrcRoot")
        path = os.path.join(srcRoot, 'BuildDescriptions', 'Release', PrgOutputDir, fileName)
        return True if os.path.exists(path) else False
        
    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteLkgSubPartElements (self, dom, node, _outputFn):
        partsWithBadPrgOutputDirs = []
        if len (self.m_lkgSubPartDict) > 0:
            subpartNode = dom.createElement ("LkgSubParts")
            node.appendChild (subpartNode)

            for key in self.m_lkgSubPartDict:
                lkgSubPartEntry = self.m_lkgSubPartDict[key]
                prodElm = dom.createElement ("LkgSubPart")
                prodElm.setAttribute ("Name", lkgSubPartEntry.TopLevelPartName)
                prodElm.setAttribute ("ReleaseVersion", str(lkgSubPartEntry.ReleaseVersion))
                prodElm.setAttribute ("MajorVersion", str(lkgSubPartEntry.MajorVersion))
                prodElm.setAttribute ("MinorVersion", str(lkgSubPartEntry.MinorVersion))
                prodElm.setAttribute ("BuildNumber", str(lkgSubPartEntry.BuildNumber))
                prodElm.setAttribute ("PrgOutputDir", lkgSubPartEntry.Name)
                prodElm.setAttribute ("LKGType", lkgSubPartEntry.LKGType)
                prodElm.setAttribute ("Url", lkgSubPartEntry.Url)
                #prodElm.setAttribute ("Released", str(self.isReleased(lkgSubPartEntry.Name, self.GetLKGVersion(key))))
                subpartNode.appendChild (prodElm)
                if "" == lkgSubPartEntry.Name:
                    partsWithBadPrgOutputDirs.append (key)

        return partsWithBadPrgOutputDirs

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def CompressLkgMapElements (self):
        consolidatedMap = {}
        uniqueEntries = []
        for key in self.m_lkgMapEntries:
            shortName, whereLkgCameFromPrgDir= self.GetLkgMapEntry (key)
            fname = "{0}:*".format (shortName.split (":")[0])
            fnamel = fname.lower()

            if fnamel in consolidatedMap:
                if consolidatedMap[fnamel][1].lower() != whereLkgCameFromPrgDir.lower():
                    if shortName.lower() == fnamel: # This happens if someone added "Something:*" to the m_lkgMapEntries
                                                    #   - entries in the map should be fully resolved.
                        msg = "Error: SubPartLkgMap found two '{0}' entries that look are looking at two different PrgOutputDirs '{1}' and '{2}'"
                        raise BuildDescriptionError (msg.format (shortName, consolidatedMap[fnamel][1], whereLkgCameFromPrgDir))

                    uniqueEntries.append ((shortName, whereLkgCameFromPrgDir))
                else: # do nothing if the prgoutputdir and the shortName are common
                    if fnamel != fname: # replace entry - this one has case
                        consolidatedMap[fnamel] = (fname, consolidatedMap[fnamel][1])
            else:
                consolidatedMap[fnamel] = (fname, whereLkgCameFromPrgDir)

        return consolidatedMap, uniqueEntries

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteLkgMapElements (self, dom, node, _outputFn):
        lkgMapEntriesWithBlankPrgDirs = []
        if len (self.m_lkgMapEntries.keys()) > 0:
            subpartNode = dom.createElement ("LkgPartMap")
            node.appendChild (subpartNode)
            
            consolidatedMap, uniqueEntries = self.CompressLkgMapElements()

            def addEntry (shortName, whereLkgCameFromPrgDir): 
                prodElm = dom.createElement ("LkgMapEntry")
                prodElm.setAttribute ("Name", shortName)
                prodElm.setAttribute ("PrgOutputDir", whereLkgCameFromPrgDir)
                subpartNode.appendChild (prodElm)
                if len (whereLkgCameFromPrgDir) == 0:
                    lkgMapEntriesWithBlankPrgDirs.append (shortName)

            for key in sorted(consolidatedMap.keys()):
                addEntry (consolidatedMap[key][0], consolidatedMap[key][1])

            for item in sorted(uniqueEntries):
                addEntry (item[0], item[1])

        return lkgMapEntriesWithBlankPrgDirs

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteContextElements (self, dom, node, _outputFn):
        if len (self.m_usedContexts) == 0:
            return 
        subpartNode = dom.createElement ("BuiltContexts")
        node.appendChild (subpartNode)

        for key in sorted(self.m_usedContexts):
            prodElm = dom.createElement ("Context")
            prodElm.setAttribute ("Name", key)
            subpartNode.appendChild (prodElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteCvsPartElements (self, dom, node, outputFn):
        if len (self.m_repoTagDict) > 0:
            subpartNode = dom.createElement ("CvsRepositories")
            node.appendChild (subpartNode)

            keylist = list(self.m_repoTagDict.keys())
            keylist.sort()
            for key in keylist:
                entry = self.m_repoTagDict[key]
                if outputFn:
                    outputFn ('Repository: name={0}, tag={1}, url={2} path={3}\n'.format (entry.Name, entry.Tag, entry.Url, entry.Path))

                prodElm = dom.createElement ("CvsRepository")
                prodElm.setAttribute ("Name", entry.Name)
                prodElm.setAttribute ("Tag", entry.Tag)
                prodElm.setAttribute ("Url", entry.Url)
                prodElm.setAttribute ("Path", entry.Path)
                subpartNode.appendChild (prodElm)
                
    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteRsyncPartElements (self, dom, node, outputFn):
        if len (self.m_rsyncRepoDict) > 0:
            subpartNode = dom.createElement ("RsyncRepositories")
            node.appendChild (subpartNode)

            keylist = list(self.m_rsyncRepoDict.keys())
            keylist.sort()
            for key in keylist:
                entry = self.m_rsyncRepoDict[key]
                if outputFn:
                    outputFn ('Repository: name={0}, tag={1}, url={2}, path={3}\n'.format (entry.Name, entry.Tag, entry.Url, entry.Path))

                prodElm = dom.createElement ("RsyncRepository")
                prodElm.setAttribute ("Name", entry.Name)
                prodElm.setAttribute ("Tag", entry.Tag)
                prodElm.setAttribute ("Url", entry.Url)
                prodElm.setAttribute ("Path", entry.Path)
                subpartNode.appendChild (prodElm)
                
    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteSdkSourcePartElements (self, dom, node, outputFn):
        if len (self.m_sdkSourceRepoDict) > 0:
            subpartNode = dom.createElement ("SdkSources")
            node.appendChild (subpartNode)

            keylist = list(self.m_sdkSourceRepoDict.keys())
            keylist.sort()
            for key in keylist:
                entry = self.m_sdkSourceRepoDict[key]
                if outputFn:
                    outputFn ('SdkSource: name={0}, version={1}, prgoutputdir={2}, sdkname={3}\n'.format (entry.Name, entry.Version, entry.PrgOutputDir, entry.SdkName))

                prodElm = dom.createElement ("SdkSource")
                prodElm.setAttribute ("Name", entry.Name)
                prodElm.setAttribute ("Version", entry.Version)
                prodElm.setAttribute ("PrgOutputDir", entry.PrgOutputDir)
                prodElm.setAttribute ("SdkName", entry.SdkName)
                subpartNode.appendChild (prodElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteNugetPackagePartElements (self, dom, node, _outputFn):
        if len (self.m_nugetPackages) > 0:
            subpartNode = dom.createElement ("NugetPackages")
            node.appendChild (subpartNode)

            for entry in sorted(self.m_nugetPackages):
                prodElm = dom.createElement ("NugetPackage")
                prodElm.setAttribute ("Name", entry.Name)
                if entry.Alias:
                    prodElm.setAttribute ("Alias", entry.Alias)
                prodElm.setAttribute ("Version", entry.Version)
                prodElm.setAttribute ("Url", entry.Url)
                subpartNode.appendChild (prodElm)
                
    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteNpmPackagePartElements (self, dom, node, _outputFn):
        if len (self.m_npmPackageDict) > 0:
            subpartNode = dom.createElement ("NpmPackages")
            node.appendChild (subpartNode)

            keylist = list(self.m_npmPackageDict.keys())
            keylist.sort()
            for key in keylist:
                entry = self.m_npmPackageDict[key]
                prodElm = dom.createElement ("NpmPackage")
                prodElm.setAttribute ("Name", entry.Name)
                prodElm.setAttribute ("Version", entry.Version)
                prodElm.setAttribute ("Url", entry.Url)
                prodElm.setAttribute ("Dev", repr(entry.Dev))
                subpartNode.appendChild (prodElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteUniversalPackagePartElements (self, dom, node, _outputFn):
        if len (self.m_upacks) > 0:
            subpartNode = dom.createElement ("UniversalPackages")
            node.appendChild (subpartNode)

            for entry in sorted(self.m_upacks):
                prodElm = dom.createElement ("UniversalPackage")
                prodElm.setAttribute ("Name", entry.Name)
                if entry.Alias:
                    prodElm.setAttribute ("Alias", entry.Alias)
                prodElm.setAttribute ("Version", entry.Version)
                prodElm.setAttribute ("Url", entry.Url)
                prodElm.setAttribute ("Feed", entry.Feed)
                subpartNode.appendChild (prodElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    # Class:BuildDescription
    #-------------------------------------------------------------------------------------------
    def WriteADOBuildArtifactPartElements (self, dom, node, _outputFn):
        if len (self.m_adoBuildArtifacts) > 0:
            subpartNode = dom.createElement ("ADOBuildArtifacts")
            node.appendChild (subpartNode)

            for entry in sorted(self.m_adoBuildArtifacts):
                prodElm = dom.createElement ("ADOBuildArtifact")
                prodElm.setAttribute ("Name", entry.Name)
                prodElm.setAttribute ("Alias", entry.Alias)
                prodElm.setAttribute ("ADOBuildId", str(entry.ADOBuildId))
                prodElm.setAttribute ("DefinitionId", str(entry.DefinitionId))
                prodElm.setAttribute ("Project", entry.Project)
                prodElm.setAttribute ("Organization", entry.Organization)
                subpartNode.appendChild (prodElm)

    #-------------------------------------------------------------------------------------------
    # bsiclass
    #-------------------------------------------------------------------------------------------
    def WriteCreatedPackages(self, dom, node, outputFn):
        if len(self.m_createdPackages) > 0:
            productNode = dom.createElement("CreatedPackages")
            node.appendChild(productNode)

            keylist = list(self.m_createdPackages.keys())
            keylist.sort()
            for key in keylist:
                entry = self.m_createdPackages[key]
                if outputFn:
                    outputFn ('CreatedPackage: name={0}, version={1}, type={2}\n'.format (entry.Name, entry.Version, entry.Type))

                prodElm = dom.createElement ("CreatedPackage")
                prodElm.setAttribute ("Name", entry.Name)
                prodElm.setAttribute ("Version", entry.Version)
                prodElm.setAttribute ("Type", entry.Type)
                prodElm.setAttribute ("Url", entry.Url)
                productNode.appendChild (prodElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteBundleElements (self, dom, node, _outputFn):
        if len (self.m_bundles) > 0:
            subpartNode = dom.createElement ("Bundles")
            node.appendChild (subpartNode)

            keylist = list(self.m_bundles.keys())
            keylist.sort()
            for key in keylist:
                entry = self.m_bundles[key]
                prodElm = dom.createElement ("Bundle")
                prodElm.setAttribute ("Name", entry.Name)
                prodElm.setAttribute ("Path", entry.Path)
                prodElm.setAttribute ("OrganizationName", entry.OrganizationName)
                prodElm.setAttribute ("Project", entry.Project)
                prodElm.setAttribute ("ArtifactName", entry.ArtifactName)
                prodElm.setAttribute ("AzureBuildId", entry.AzureBuildId)
                subpartNode.appendChild (prodElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteUnsavedLkgElements (self, dom, node, _outputFn):
        if len (self.m_unsavedLkgs) > 0:
            subpartNode = dom.createElement ("UnsavedLKGs")
            node.appendChild (subpartNode)

            keylist = list(self.m_unsavedLkgs.keys())
            keylist.sort()
            for key in keylist:
                name = self.m_unsavedLkgs[key]
                prodElm = dom.createElement ("UnsavedLKG")
                prodElm.setAttribute ("Name", name)
                subpartNode.appendChild (prodElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteBootstrap (self, dom, node, _outputFn):
        if not self.m_bootstrapInfo:
            return
        subpartNode = dom.createElement ("Bootstrap")
        node.appendChild (subpartNode)

        keylist = list(self.m_bootstrapInfo.keys())
        keylist.sort()
        for key in keylist:
            item = self.m_bootstrapInfo[key]
            prodElm = dom.createElement ("Repo")
            prodElm.setAttribute ("Name", item.Name)
            prodElm.setAttribute ("RepoType", item.RepoType)
            prodElm.setAttribute ("IsPrimary", 'true' if item.IsPrimary else 'false')
            prodElm.setAttribute ("LocalDir", item.LocalDir)
            subpartNode.appendChild (prodElm)

    #-------------------------------------------------------------------------------------------
    # bsiclass
    #-------------------------------------------------------------------------------------------
    def WriteCreatedPackageLicenses(self, dom, node, _outputFn):
        # Common place to edit the attribute names, if needed
        def addElement(package, licNode):

            licenseElm = dom.createElement ("PackageLicense")
            licenseElm.setAttribute("PackageName", package.PackageName)
            licenseElm.setAttribute("Version", package.Version)
            licenseElm.setAttribute("PackageHomePage", package.PackageHomePage)
            licenseElm.setAttribute("LicenseName", package.LicenseName)
            licenseElm.setAttribute("LicenseLink", package.LicenseLink)
            licenseElm.setAttribute("Copyright", package.Copyright)
            licenseElm.setAttribute("Type", package.Type)
            if (package.SubpackageVersion):
                licenseElm.setAttribute("SubpackageName", package.SubpackageName)
                licenseElm.setAttribute("SubpackageVersion", package.SubpackageVersion)

            licNode.appendChild (licenseElm)

        licenseNode = None
        if len(self.m_nugetPackageLicenses) > 0:
            licenseNode = dom.createElement("PackageLicenses")
            node.appendChild(licenseNode)

            for entry in self.m_nugetPackageLicenses:
                addElement(entry, licenseNode)

        if len(self.m_npmPackageLicenses) > 0:
            if licenseNode == None:
                licenseNode = dom.createElement("PackageLicenses")
                node.appendChild(licenseNode)

            for entry in self.m_npmPackageLicenses:
                addElement(entry, licenseNode)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def loadBuildTimeIso (self):
        # Only load it once
        if self.m_buildTimeIso:
            return

        bdfBuildTime = datetime.datetime.utcnow().isoformat()
        # Python 2.7 datetime doesn't support timezone offsets in isoformat, so we'll append it here if we have to
        # When we upgrade to Python 3.0, we can instead just call datetime.datetime.now(datetime.timezone.utc).isoformat()
        # i.e. has the +00:00 UTC timezone offset
        if "+" not in bdfBuildTime:
            bdfBuildTime = bdfBuildTime + "+00:00"
        self.m_buildTimeIso = bdfBuildTime

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetEnvirnomentVars (self):
        # If they were read in, use the read values; otherwise read the current environment
        if len (self.m_environment) == 0:
            # If we need to load the BUILDTIME value, also load the BuildTimeISO
            self.loadBuildTimeIso()

            # Keep the old format for the legacy format
            self.m_environment['BUILDTIME'] = datetime.datetime.now().strftime(BUILDTIME_FORMAT)

            envVars = [
                'PRG', 'SUBNET_PRG', 'DEBUG', 'NDEBUG', 'COMPUTERNAME', 'USERNAME'
            ]
            for currentVar in envVars:
                value = "" if not currentVar in os.environ else os.environ[currentVar]
                self.m_environment[currentVar] = value
        
        return self.m_environment

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def GetEnvirnomentVarsStrict (self): 
        #returns only the environment variables read from a file 
        return self.m_environment

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteEnvirnomentVars (self, dom, node):
        subpartNode = dom.createElement("AsBuiltEnvironment")
        node.appendChild(subpartNode)
        
        envVarDict = self.GetEnvirnomentVars()
        
        for envName in envVarDict:
            value = envVarDict[envName]
            prodElm = dom.createElement("Env")
            prodElm.setAttribute("Name" , envName)
            prodElm.setAttribute("Value" , value)
            subpartNode.appendChild(prodElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteStreamAndStrategy (self, dom, node):
        #  Strategy
        stratName = self.m_strategyName if None != self.m_strategyName else ""
        stratElm = dom.createElement ("Strategy")
        stratElm.setAttribute ("Name", stratName)
        node.appendChild (stratElm)

        #  Stream
        streamName = self.m_streamName if None != self.m_streamName else ""
        streamElm = dom.createElement ("Stream")
        streamElm.setAttribute ("Name", streamName)
        node.appendChild (streamElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteProduct (self, dom, node):
        #  Product name and version
        verElm = dom.createElement ("Product")
        verElm.setAttribute ("Name", self.m_prodName)
        verElm.setAttribute ("ReleaseVersion", str(self.m_version[0]))
        verElm.setAttribute ("MajorVersion", str(self.m_version[1]))
        verElm.setAttribute ("MinorVersion", str(self.m_version[2]))
        verElm.setAttribute ("BuildNumber", str(self.m_version[3]))
        if self.m_PRGDirName:
            verElm.setAttribute ("PrgOutputDir", self.m_PRGDirName)
        verElm.setAttribute ("PrgProductId", str(self.m_prgProductId))
        verElm.setAttribute ("BuildType", str(self.m_buildType))
        if self.m_buildTimeIso:
            verElm.setAttribute ("BuildTimeISO", self.m_buildTimeIso)
        node.appendChild (verElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteADOBuildProperties (self, dom, node):
        # ADO Build Properties (build environment)
        if 'TF_BUILD' in os.environ:
            propertiesElm = dom.createElement ("ADOBuildProperties")
            propertiesElm.setAttribute("AgentName", "" if not 'AGENT_NAME' in os.environ else os.environ['AGENT_NAME'])
            propertiesElm.setAttribute("BuildNumber", "" if not 'BUILD_BUILDNUMBER' in os.environ else os.environ['BUILD_BUILDNUMBER'])
            propertiesElm.setAttribute("BuildUri", "" if not 'BUILD_BUILDURI' in os.environ else os.environ['BUILD_BUILDURI'])
            propertiesElm.setAttribute("BuildDefinitionName", "" if not 'BUILD_DEFINITIONNAME' in os.environ else os.environ['BUILD_DEFINITIONNAME'])
            propertiesElm.setAttribute("BuildDefinitionId", "" if not 'SYSTEM_DEFINITIONID' in os.environ else os.environ['SYSTEM_DEFINITIONID'])
            propertiesElm.setAttribute("BuildQueuedBy", "" if not 'BUILD_QUEUEDBY' in os.environ else os.environ['BUILD_QUEUEDBY'])
            propertiesElm.setAttribute("BuildReason", "" if not 'BUILD_REASON' in os.environ else os.environ['BUILD_REASON'])
            propertiesElm.setAttribute("BuildRequestedFor", "" if not 'BUILD_REQUESTEDFOR' in os.environ else UnicodeIgnoringErrors(os.environ['BUILD_REQUESTEDFOR']))
            propertiesElm.setAttribute("BuildSourceBranchName", "" if not 'BUILD_SOURCEBRANCHNAME' in os.environ else os.environ['BUILD_SOURCEBRANCHNAME'])
            propertiesElm.setAttribute("ADOBuildId", "" if not 'BUILD_BUILDID' in os.environ else os.environ['BUILD_BUILDID'])
            propertiesElm.setAttribute("ProjectId", "" if not 'SYSTEM_TEAMPROJECTID' in os.environ else os.environ['SYSTEM_TEAMPROJECTID'])
            propertiesElm.setAttribute("ProjectName", "" if not 'SYSTEM_TEAMPROJECT' in os.environ else os.environ['SYSTEM_TEAMPROJECT'])
            propertiesElm.setAttribute("OrganizationName", "" if not 'SYSTEM_COLLECTIONURI' in os.environ else os.environ['SYSTEM_COLLECTIONURI'].split("/")[-1])
            propertiesElm.setAttribute("OrganizationId", "" if not 'SYSTEM_COLLECTIONID' in os.environ else os.environ['SYSTEM_COLLECTIONID'])
            node.appendChild (propertiesElm)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteToXmlFile (self, fileName, outputFn, repoListOnly):
        try:
            listfileDir = os.path.split (fileName)[0]
            if not os.path.exists (listfileDir):
                os.makedirs (listfileDir)

            bdescDom = minidom.Document()

            self.loadBuildTimeIso ()
            bdescNode = bdescDom.createElement ("BuildDescription")
            bdescDom.appendChild (bdescNode)

            if not repoListOnly:
                self.WriteStreamAndStrategy (bdescDom, bdescNode)
                self.WriteProduct (bdescDom, bdescNode)
                self.WriteADOBuildProperties (bdescDom, bdescNode)

            #  Repositories
            self.WriteGitRepositoryElements (bdescDom, bdescNode, outputFn)
            self.WriteRepositoryElements (bdescDom, bdescNode, outputFn)

            if not repoListOnly:
                #  LKG Subparts
                lkgSupPartsWithBlankPrgDirs = self.WriteLkgSubPartElements (bdescDom, bdescNode, outputFn)

                #  LkgPartMap
                lkgMapEntriesWithBlankPrgDirs = self.WriteLkgMapElements (bdescDom, bdescNode, outputFn)
            
                # Build Contexts used by this part
                self.WriteContextElements (bdescDom, bdescNode, outputFn)

                # CVS parts
                self.WriteCvsPartElements (bdescDom, bdescNode, outputFn)

                # RSync parts
                self.WriteRsyncPartElements (bdescDom, bdescNode, outputFn)

                # LKG Components
                self.WriteSdkSourcePartElements (bdescDom, bdescNode, outputFn)

                # Nuget packages
                self.WriteNugetPackagePartElements (bdescDom, bdescNode, outputFn)

                # Npm packages
                self.WriteNpmPackagePartElements (bdescDom, bdescNode, outputFn)

                # Universal packages
                self.WriteUniversalPackagePartElements (bdescDom, bdescNode, outputFn)

                # Azure devops build artifacts
                self.WriteADOBuildArtifactPartElements (bdescDom, bdescNode, outputFn)

                # Create packages
                self.WriteCreatedPackages(bdescDom, bdescNode, outputFn)

                # Package licenses
                self.WriteCreatedPackageLicenses(bdescDom, bdescNode, outputFn)

                # Bundle packages
                self.WriteBundleElements (bdescDom, bdescNode, outputFn)

                # Unsaved LKGs
                self.WriteUnsavedLkgElements (bdescDom, bdescNode, outputFn)

                # Bootstrap information
                self.WriteBootstrap (bdescDom, bdescNode, outputFn)

                if self.m_writeEnvironment :
                    self.WriteEnvirnomentVars(bdescDom, bdescNode)

            with codecs.open(fileName, mode='w', encoding='utf-8') as lfile:
                if not lfile:
                    return 1,  "Error: could not open Build Description file '{0}'.".format (fileName)
                bdescDom.writexml(lfile, indent="", addindent="  ", newl="\n", encoding="UTF-8")
            bdescDom.unlink()  # Recommended by current docs to free doms this way

            # Make sure lkg subparts and lkgmap entries have nonempty PrgOutputDirs
            if len (lkgSupPartsWithBlankPrgDirs):
                msg = ""
                for part in lkgSupPartsWithBlankPrgDirs:
                    msg += "\n " + part
                return 1, "Warning: Build Description created but contains SubPartLkgs without PrgOutputDirs. These are required to consume chained LKGs: {0}".format (msg)

            if len (lkgMapEntriesWithBlankPrgDirs) > 0:
                msg = ""
                for shortName in lkgMapEntriesWithBlankPrgDirs:
                    msg += "\n " + shortName
                return 1, "Warning: Build Description created but contains LkgMapEntries without without PrgOutputDirs. These are required to consume chained LKGs: {0}".format (msg)

        except Exception as err:
            return 1, "Error generating Build Description: {0}".format (str(err))

        return 0, "Succeeded"


    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteToFile (self, fileName, overwrite, outputFn, repoListOnly, languageName=None, asJson=False):
        if os.path.exists (fileName) and not overwrite:
            return 2, "Error: destination file '{0}' already exists.".format (fileName)

        fileName = os.path.abspath (fileName)

        # If it's just a directory, write it with the default filename
        if os.path.isdir (fileName):
            filebase = self.m_PRGDirName
            if not filebase:
                filebase = 'UnknownName'
            filebase = VersionedFileName (filebase, self.m_version, languageName, asJson)
            fileName = os.path.join (fileName, filebase)

        if asJson:
            return self.WriteToJsonFile (fileName, outputFn)
        else:
            return self.WriteToXmlFile (fileName, outputFn, repoListOnly)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def WriteReport (self, fileName):

        fileName = os.path.abspath (fileName)

        if os.path.isdir (fileName):
            return 1, "Invalid report filename"

        report = open (fileName, "wt")

        report.write ("Last Known Good versions:\n")
        report.write ("-------------------------\n")
        for key in self.m_lkgSubPartDict:
            lkgSubPartEntry = self.m_lkgSubPartDict[key]

            lkgName = lkgSubPartEntry.TopLevelPartName.split (":")

            report.write ("Part: {1:40} SubPart: {2:40}   Version: {3:0>2}.{4:0>2}.{5:0>2}.{6:0>2}      PrgOutputDir: {0:15}    Released: {7:6} \n" \
                .format (lkgSubPartEntry.Name, lkgName[0], lkgName[1], \
                lkgSubPartEntry.ReleaseVersion, lkgSubPartEntry.MajorVersion, lkgSubPartEntry.MinorVersion, lkgSubPartEntry.BuildNumber, \
                str(self.isReleased(lkgSubPartEntry.Name, self.GetLKGVersion(key)))))

        report.write ("\n\nCVS part versions:\n")
        report.write ("------------------\n")

        keylist = list(self.m_repoTagDict.keys())
        keylist.sort()
        for key in keylist:
            item = self.m_repoTagDict[key]
            report.write ("Part: {0:40}  Tag: {1}\n".format (key, item.Tag))

        report.close()

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def _copyMissingDictItems (self, myDict, otherDict):
        for key in otherDict:
            if not key in myDict:
                myDict[key] = otherDict[key]

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def MergeRepos (self, otherBdf):
        # Merge in any repositories that are only in otherBdf into this BDF
        self._copyMissingDictItems (self.m_repoGuidDict, otherBdf.m_repoGuidDict)
        self._copyMissingDictItems (self.m_gitRepoGuidDict, otherBdf.m_gitRepoGuidDict)
        self._copyMissingDictItems (self.m_repoTagDict, otherBdf.m_repoTagDict) # CVS
        self._copyMissingDictItems (self.m_rsyncRepoDict, otherBdf.m_rsyncRepoDict)

    #-------------------------------------------------------------------------------------------
    # bsimethod
    #-------------------------------------------------------------------------------------------
    def MergePackages (self, otherBdf):
        # Merge in any packages that are only in otherBdf into this BDF
        self._copyMissingDictItems (self.m_sdkSourceRepoDict, otherBdf.m_sdkSourceRepoDict)
        self._copyMissingDictItems (self.m_npmPackageDict, otherBdf.m_npmPackageDict)
        self._copyMissingDictItems (self.m_lkgSubPartDict, otherBdf.m_lkgSubPartDict)
        self._copyMissingDictItems (self.m_bundles, otherBdf.m_bundles)

        for up in otherBdf.m_nugetPackages:
            if not self._FindNuget (up.Name, up.Alias):
                self.m_nugetPackages.add(up)

        for up in otherBdf.m_upacks:
            if not self._FindUpack (up.Name, up.Alias):
                self.m_upacks.add(up)

        for up in otherBdf.m_adoBuildArtifacts:
            if not self._FindADOBuildArtifact (up.Alias):
                self.m_adoBuildArtifacts.add(up)

#-------------------------------------------------------------------------------------------
# bsimethod
#-------------------------------------------------------------------------------------------
def GetFileNameFromVersion (prodName, version, rebuildNumber="0"):
    return '{0}_{1}.xml'.format(prodName, getDirStrForVersion(version, rebuildNumber))

#-------------------------------------------------------------------------------------------
# bsimethod
#-------------------------------------------------------------------------------------------
def getDirStrForVersion (ver, rebuildNumber="0"):
    ver = [v if v != None else 0 for v in ver]
    versionDir = "{0}-{1}-{2}-{3}".format (str(int(ver[0])), str(int(ver[1])), str(int(ver[2])), str(int(ver[3])))
    if "0" != str(int(rebuildNumber)):
        versionDir = "{0}b{1}".format (versionDir, rebuildNumber) 
    return versionDir

#-------------------------------------------------------------------------------------------
# bsimethod
#-------------------------------------------------------------------------------------------
def GetVersionFromDirStr (dirstr):
    # Check for rebuild number
    rebuild = False
    if 'b' in dirstr:
        rebuild = True
        dirstr = dirstr.replace ('b', '-')
        
    verlist = dirstr.split ('-')
    if not rebuild:
        verlist.append ('0')
        
    return tuple (map(int, verlist))

#-------------------------------------------------------------------------------------------
# bsimethod
#-------------------------------------------------------------------------------------------
def ExtractVersionFromFilename (fileName):
    fn, _ = os.path.splitext (fileName)
    ubarIndex =  fn.find ('_')
    if ubarIndex > 0:
        fn = fn[ubarIndex+1:]
        
    return GetVersionFromDirStr (fn)

#-------------------------------------------------------------------------------------------
# bsimethod
#-------------------------------------------------------------------------------------------
def VersionedFileName (filebase, version, languageName, asJson):
    extension = 'json' if asJson else 'xml'
    verString = '-'.join([str (verStr) for verStr in version])

    if languageName:
        return '{0}_{1}_{2}.{3}'.format(filebase, languageName, verString, extension)
    else:
        return '{0}_{1}.{2}'.format(filebase, verString, extension)

#-------------------------------------------------------------------------------------------
# bsimethod
#-------------------------------------------------------------------------------------------
def UnicodeIgnoringErrors(inString):
    if py3:
        return str(inString)

    return unicode(inString, errors='ignore') # pylint: disable=undefined-variable
